<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Multi Answers</title>
    <style>
      :root {
        --bg-1: #f7f9fc;
        --bg-2: #eef3f9;
        --tint-1: #e9eef7;
        --tint-2: #f6f0ff;
        --text: #0b1220;
        --muted: #5b6577;
        --brand: #0a84ff; /* Apple blue */
        --danger: #d70015;
        --border: rgba(0,0,0,0.08);
        --card: rgba(255,255,255,0.7);
      }
      * { box-sizing: border-box; }
      body {
        font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
        margin: 0;
        color: var(--text);
        background-image: url('michael-fousert-lE5-z4nTCTQ-unsplash.jpg');
        background-position: center center;
        background-repeat: no-repeat;
        background-attachment: fixed;
        background-size: cover; /* Fill page without distortion (may crop) */
        padding-top: 76px; /* prevent overlap with fixed brand */
      }
      body.video-on { background-image: none; }
      body.max-on { padding-top: 0; }
      /* Dark mode theme overrides */
      body.dark {
        --text: #eef3fb;
        --muted: #b7c3d6;
        --border: rgba(255,255,255,0.16);
        --card: rgba(28,34,44,0.55); /* lighter than before */
      }
      /* Header removed per request */
      .container { max-width: 95%; margin: 0 auto; padding: 12px 16px; }
      h2 { margin: 0; font-weight: 700; letter-spacing: 0.2px; }
      p.small { color: var(--muted); margin-top: 6px; }
      .grid-3, .row { display: grid; grid-template-columns: 1fr 2fr 1fr; gap: 16px; align-items: start; }
      /* Ensure the answers row specifically uses wider center column */
      .answers.row { grid-template-columns: 1fr 2fr 1fr; }
      .panel {
        position: relative;
        background: var(--card);
        border: 1px solid var(--border);
        border-radius: 12px;
        padding: 6px;
        backdrop-filter: blur(10px);
        box-shadow: 0 6px 16px rgba(0,0,0,0.06), inset 0 1px 0 rgba(255,255,255,0.5);
      }
      label { display: block; font-size: 12px; color: var(--muted); margin-bottom: 6px; }
      input[type="text"], textarea, select, input[type="number"] {
        width: 100%; padding: 10px 12px; border-radius: 12px;
        border: 1px solid var(--border); background: rgba(255,255,255,0.8);
        color: var(--text); outline: none; box-shadow: inset 0 1px 0 rgba(255,255,255,0.6);
        font-size: 16px; font-family: inherit;
      }
      textarea { min-height: 90px; }
      textarea#prompt { min-height: 40px; max-height: 140px; resize: none; overflow: auto; transition: height 0.2s ease; }
      .attachments-row { display: flex; gap: 8px; flex-wrap: wrap; align-items: center; margin: -6px 0 4px 0; }
      .chip { display: inline-flex; align-items: center; gap: 6px; padding: 4px 8px; border: 1px solid var(--border); border-radius: 999px; background: rgba(255,255,255,0.65); color: var(--muted); font-size: 12px; }
      .chip .remove { cursor: pointer; color: #b00020; font-weight: 600; }
      .toolbar { display: flex; flex-wrap: wrap; gap: 10px; align-items: center; }
      .btn { 
        padding: 10px 14px; border: 1px solid rgba(10,132,255,0.25);
        border-radius: 12px; background: linear-gradient(180deg, rgba(10,132,255,0.25), rgba(10,132,255,0.18));
        color: #0b1220; font-weight: 600; cursor: pointer;
        box-shadow: 0 6px 22px rgba(10,132,255,0.12), inset 0 1px 0 rgba(255,255,255,0.6);
      }
      .btn-wide { min-width: 260px; }
      /* Same vertical rhythm as .btn, just shorter width and smaller font */
      .btn-sm { padding: 10px 12px; font-size: 12px; display: inline-flex; align-items: center; }
      .btn:disabled { opacity: 0.6; cursor: not-allowed; }
      .switch { display: inline-flex; align-items: center; gap: 6px; font-size: 13px; color: var(--muted); }
      .pill { display: inline-flex; align-items: center; gap: 6px; padding: 4px 8px; border-radius: 999px; border: 1px solid var(--border); background: rgba(255,255,255,0.7); color: var(--muted); font-size: 12px; }

      /* Floating prompt panel (independent window) */
      #panel-bottom {
        position: fixed;
        left: 50%;
        bottom: 12px;
        transform: translateX(-50%);
        width: min(900px, 92vw);
        z-index: 2000;
        margin-top: 0 !important;
        pointer-events: auto;
        padding: 6px;
      }
      /* Thin drag strip on top of the prompt panel so dragging never conflicts with inputs */
      #panel-bottom .panel-drag-strip {
        position: absolute; top: 0; left: 0; right: 0; height: 12px; cursor: move;
        border-top-left-radius: 12px; border-top-right-radius: 12px;
        z-index: 1;
      }
      .control-panel-section { transition: max-height 0.25s ease, opacity 0.25s ease; overflow: hidden; }
      .control-panel-section.hidden { max-height: 0; opacity: 0; margin-top: 0; padding-top: 0; }
      .control-panel-section:not(.hidden) { max-height: 520px; opacity: 1; }
      .toggle-controls-btn { position: absolute; top: 8px; right: 8px; font-size: 12px; }

      /* Make conversation windows utilize screen space (independent of prompt panel) */
      .answers { min-height: 100vh; padding-bottom: 24px; }
      .card { min-height: 200px; }
      /* .convo max-height is defined later for cards; keep it local and independent */
      
      /* Control panel toggle */
      .control-panel-section { transition: all 0.3s ease; overflow: hidden; }
      .control-panel-section.hidden { max-height: 0; opacity: 0; margin: 0; padding: 0; }
      .control-panel-section:not(.hidden) { max-height: 500px; opacity: 1; }
      .settings-fab {
        position: fixed; top: 12px; left: 12px; z-index: 3000;
        width: 36px; height: 36px; border-radius: 50%;
        display: grid; place-items: center; cursor: pointer;
        background: rgba(15,18,24,0.45); color: #eaf2ff; border: 1px solid rgba(255,255,255,0.28);
        box-shadow: 0 6px 24px rgba(0,0,0,0.18), inset 0 1px 0 rgba(255,255,255,0.35);
        backdrop-filter: blur(10px);
      }
      .settings-fab:hover { background: rgba(15,18,24,0.65); }
      .settings-modal {
        position: fixed; inset: 0; display: none; align-items: center; justify-content: center; z-index: 4000;
        background: rgba(0,0,0,0.35);
      }
      .settings-modal.open { display: flex; }
      .settings-sheet {
        width: min(820px, 92vw); max-height: min(80vh, 760px); overflow: auto;
        background: var(--card); border: 1px solid var(--border); border-radius: 16px; padding: 16px;
        box-shadow: 0 18px 60px rgba(0,0,0,0.28);
      }
      .answers { margin-top: 4px; position: relative; }
      .card {
        position: relative; background: var(--card);
        border: 1px solid var(--border); border-radius: 12px; padding: 10px;
        min-height: 200px; white-space: pre-wrap; backdrop-filter: blur(12px);
        box-shadow: 0 8px 18px rgba(0,0,0,0.06), inset 0 1px 0 rgba(255,255,255,0.5);
        resize: none; overflow: auto; min-width: 240px; min-height: 200px;
        display: flex; flex-direction: column;
      }
      /* Subtle per-card tint; center uses a randomized base hue set in JS */
      .card { --tint-h: 210; --tint-s: 65%; --tint-l: 96%; --tint-a: 0.65; }
      .card { background: radial-gradient(circle at 50% 38%, hsla(var(--tint-h), var(--tint-s), var(--tint-l), var(--tint-a)), rgba(255,255,255,0.55) 68%); }
      body.dark .card { background: radial-gradient(circle at 50% 38%, hsla(var(--tint-h), 65%, 34%, 0.32), rgba(20,24,30,0.60) 68%); border-color: rgba(255,255,255,0.14); }
      /* Smooth brand-style panel animation (like top-left title) */
      .card::before {
        content: '';
        position: absolute; inset: -2px;
        border-radius: inherit; pointer-events: none;
        opacity: 0; transition: opacity 600ms ease;
        background: linear-gradient(90deg,
          hsl(210, 90%, 60%),
          hsl(280, 90%, 62%),
          hsl(340, 90%, 62%),
          hsl(210, 90%, 60%)
        );
        background-size: 400% 100%;
        mix-blend-mode: screen;
      }
      /* Subtle internal tint */
      .card::before {
        content: '';
        position: absolute; inset: 0;
        border-radius: inherit; pointer-events: none;
        background: hsla(var(--tint-h,210), 96%, 60%, 0.06);
        mix-blend-mode: screen;
        opacity: 0; transition: opacity 300ms ease;
      }
      /* Border glow active only during loading */
      .card::after {
        content: '';
        position: absolute; inset: 0;
        border-radius: inherit; pointer-events: none;
        box-shadow:
          0 0 0 2px hsla(var(--tint-h,210), 96%, 60%, 0.55) inset,
          0 0 24px hsla(var(--tint-h,210), 96%, 60%, 0.32) inset;
        opacity: 0; transition: opacity 300ms ease;
      }
      .card.loading { animation: none; }
      .card.loading::before { opacity: 0.28; animation: brandFlow 30s ease-in-out infinite; }
      body.dark .card.loading::before { opacity: 0.22; }
      .card.loading::after { opacity: 0.8; }
      .card.loading::after { animation: hueSpin 90s linear infinite; }
      .card.loading::before { animation: hueSpin 90s linear infinite; }
      @keyframes hueSpin {
        0%   { filter: hue-rotate(0deg); }
        100% { filter: hue-rotate(360deg); }
      }
      .card.tinted::before { opacity: 1; }
      /* brandFlow keyframes already defined for the brand title; reused here */
      /* Custom resize handles on all edges and corners */
      .resize-handle { position: absolute; background: transparent; border: none; z-index: 10; }
      .resize-handle:hover { background: transparent; }
      .resize-n  { top: -4px; left: 10px; right: 10px; height: 8px; cursor: n-resize; }
      .resize-s  { bottom: -4px; left: 10px; right: 10px; height: 8px; cursor: s-resize; }
      .resize-w  { left: -4px; top: 10px; bottom: 10px; width: 8px; cursor: w-resize; }
      .resize-e  { right: -4px; top: 10px; bottom: 10px; width: 8px; cursor: e-resize; }
      .resize-nw { top: -4px; left: -4px; width: 12px; height: 12px; cursor: nw-resize; border-radius: 6px; }
      .resize-ne { top: -4px; right: -4px; width: 12px; height: 12px; cursor: ne-resize; border-radius: 6px; }
      .resize-sw { bottom: -4px; left: -4px; width: 12px; height: 12px; cursor: sw-resize; border-radius: 6px; }
      .resize-se { bottom: -4px; right: -4px; width: 12px; height: 12px; cursor: se-resize; border-radius: 6px; }
      /* Individual card resizing only - no column resizers */
      .card h3 { position: sticky; top: 0; z-index: 3; display: flex; align-items: center; justify-content: space-between; margin: 0 0 6px 0; font-size: 14px; font-weight: 500; background: transparent; backdrop-filter: none; border-bottom: none; padding-top: 6px; }
      .card h3 { cursor: move; user-select: none; }
      .mini { margin-top: 4px; display: flex; gap: 8px; align-items: center; --mini-collapsed: 220px; position: sticky; bottom: 0; z-index: 2; background: transparent; border-top: none; padding-top: 6px; }
      /* Prompt row: buttons to the left, textarea to the right */
      .prompt-row { display: flex; gap: 8px; align-items: flex-start; }
      .prompt-row .left-controls { display: flex; flex-direction: column; gap: 6px; }
      .prompt-row .right-controls { display: flex; flex-direction: row; gap: 6px; }
      :root { --follow-lh: 18px; }
      .mini input[type="text"], .mini textarea.follow {
        flex: 1 1 auto; width: 100%; max-width: var(--mini-collapsed, 220px);
        padding: 6px 10px; border-radius: 10px; border: 1px solid var(--border);
        background: rgba(10,10,10,0.65); color: #eaeef7; font-size: 13px; line-height: var(--follow-lh);
        transition: max-width 0.25s ease, padding 0.18s ease, font-size 0.18s ease, height 0.15s ease; resize: none;
        min-height: calc(var(--follow-lh) * 2 + 12px);
        max-height: calc(var(--follow-lh) * 5 + 12px);
        height: calc(var(--follow-lh) * 2 + 12px);
        overflow-y: auto;
      }
      /* Expand follow-up when user hovers the convo OR focuses the input */
      .mini input[type="text"]:focus, .mini textarea.follow:focus,
      .convo:hover + .mini input[type="text"], .convo:hover + .mini textarea.follow,
      .convo:focus + .mini input[type="text"], .convo:focus + .mini textarea.follow { padding: 8px 12px; font-size: 15px; }
      /* Expand width on hover over the input or its mini bar */
      .mini:hover input[type="text"], .mini input[type="text"]:hover,
      .mini:hover textarea.follow, .mini textarea.follow:hover { max-width: 100%; }
      .mini .mini-btn { padding: 8px 12px; border: 1px solid rgba(10,132,255,0.25); border-radius: 10px; background: linear-gradient(180deg, rgba(10,132,255,0.2), rgba(10,132,255,0.12)); font-weight: 600; cursor: pointer; }
      .controls { display: inline-flex; gap: 6px; align-items: center; margin-left: 8px; }
      .icon-btn { padding: 4px 8px; border: 1px solid var(--border); border-radius: 8px; background: rgba(255,255,255,0.7); cursor: pointer; font-size: 12px; }
      /* Compact per-card model selector */
      .model-select {
        font-size: 12px;
        padding: 6px 8px;
        border-radius: 10px;
        border: 1px solid var(--border);
        background: rgba(255,255,255,0.85);
        color: var(--text);
        max-width: 220px;
      }
      body.dark .model-select {
        background: rgba(24,26,32,0.92);
        color: #eef3fb;
        border-color: rgba(255,255,255,0.12);
      }
      
      /* Hover lighting effect for interactive buttons */
      button, .btn, .mini-btn, .icon-btn {
        transition: box-shadow 0.35s ease, filter 0.35s ease;
      }
      button:hover, .btn:hover, .mini-btn:hover, .icon-btn:hover {
        box-shadow: 0 0 0px rgba(10,132,255,0.0), 0 0 0px rgba(10,132,255,0.0);
        animation: glowUp 0.35s forwards;
      }
      button:active, .btn:active, .mini-btn:active, .icon-btn:active {
        box-shadow: 0 0 16px rgba(10,132,255,0.8), 0 0 8px rgba(10,132,255,0.9);
        filter: brightness(1.28);
      }
      @keyframes glowUp {
        0% { box-shadow: 0 0 0px rgba(10,132,255,0.0), 0 0 0px rgba(10,132,255,0.0); filter: brightness(1); }
        100% { box-shadow: 0 0 12px rgba(10,132,255,0.45), 0 0 4px rgba(10,132,255,0.65); filter: brightness(1.12); }
      }
      .dot {
        transition: box-shadow 0.3s ease, transform 0.3s ease;
      }
      .dot {
        transition: box-shadow 0.35s ease, transform 0.35s ease;
      }
      .dot:hover {
        animation: dotGlow 0.35s forwards;
      }
      .dot:active {
        box-shadow: 0 0 12px rgba(255,255,255,1);
        transform: scale(1.35);
      }
      @keyframes dotGlow {
        0% { box-shadow: 0 0 0px rgba(255,255,255,0); transform: scale(1); }
        100% { box-shadow: 0 0 8px rgba(255,255,255,0.8); transform: scale(1.25); }
      }
      .card h3 .title {
        display: none !important;
      }
      .card h3 .title span { position: relative; font-weight: 500; letter-spacing: 0.2px; }
      /* Remove previous shiny loading effects */
      .card.loading .title span, .card.loading .title span::before, .card.loading .title span::after { animation: none; background: none; color: inherit; filter: none; }
      /* Removed shine/sparkle progress-like effects; only emoji sparks remain */
      /* Emoji sparks that pop around model names while loading */
      .spark {
        position: absolute;
        top: 50%; left: 50%;
        transform: translate(-50%, -50%);
        pointer-events: none;
        user-select: none;
        filter: drop-shadow(0 1px 1px rgba(0,0,0,0.25));
        animation: pop-float var(--d, 1.2s) ease-out forwards;
        will-change: transform, opacity;
      }
      @keyframes pop-float {
        0% { opacity: 0; transform: translate(calc(-50% + var(--x, 0px)), calc(-50% + 6px)) scale(0.6) rotate(0deg); }
        12% { opacity: 1; transform: translate(calc(-50% + var(--x, 0px)), calc(-50% - 6px)) scale(1) rotate(var(--rot, 12deg)); }
        100% { opacity: 0; transform: translate(calc(-50% + var(--x, 0px)), calc(-50% - 70px)) scale(0.95) rotate(var(--rot, 12deg)); }
      }
      .traffic { display: inline-flex; gap: 6px; align-items: center; margin-right: 8px; }
      .dot { width: 12px; height: 12px; border-radius: 50%; cursor: pointer; border: 1px solid rgba(0,0,0,0.15); box-shadow: inset 0 1px 0 rgba(255,255,255,0.6); }
      .dot.red { background: #ff5f56; }
      .dot.yellow { background: #ffbd2e; }
      .dot.green { background: #27c93f; }
      /* Additional beautiful dots for height controls */
      .dot.blue { background: #0a84ff; }
      .dot.purple { background: #af52de; }
      .card.maximized { position: static; width: 100%; height: auto; z-index: auto; padding: 16px; border-radius: 16px; min-height: calc(100vh - 200px); margin: 0; overflow: auto; }
      .card.maximized .convo { max-height: none; min-height: 60vh; padding: 12px; overflow: visible; }
      /* Minimized state: show only header tab with model name */
      .card.minimized { height: 38px !important; min-height: 0 !important; overflow: hidden; }
      .card.minimized .convo, .card.minimized .mini { display: none !important; }
      .card.minimized h3 { padding-bottom: 6px; }
      .card.maximized .msg { font-size: 1.08rem; line-height: 1.6; padding: 12px 14px; }
      .card.maximized h3 { margin-bottom: 10px; font-size: 18px; }
      .card.maximized .mini { margin-top: 14px; }
      .card.maximized .mini input[type="text"] { padding: 10px 12px; font-size: 1.02rem; }
      .card.maximized .mini .mini-btn { padding: 10px 16px; font-size: 1.02rem; }
      .answers.single { display: block; }
      .answers.single .card { display: none; }
      .answers.single .card.maximized { display: block; width: 100%; max-width: none; }
      /* Isolated layout: each card positioned independently */
      .answers.isolated { position: relative; display: block; min-height: 500px; }
      .answers.isolated .card { position: absolute; }
      .convo { position: relative; /* no scrolling here; card scrolls */ max-height: none; overflow: visible; display: flex; flex-direction: column; gap: 6px; border-radius: 8px; padding: 4px; background: transparent; border-color: transparent; flex: 1 1 auto; }
      .convo[data-empty="true"] { border-color: transparent; background: transparent; }
      .msg { padding: 8px 10px; border-radius: 10px; border: 1px solid var(--border); background: rgba(255,255,255,0.8); }
      .msg.user { background: rgba(10,132,255,0.08); border-color: rgba(10,132,255,0.2); }
      .msg.assistant { background: rgba(0,0,0,0.03); }
      .latency { display:none; }
      .error { color: var(--danger); white-space: pre-wrap; }
      footer { color: var(--muted); font-size: 12px; margin-top: 16px; }
      @media (max-width: 900px) { .row, .grid-3 { grid-template-columns: 1fr; } }

       /* Details (Advanced) styling */
       details { border: 1px solid var(--border); border-radius: 12px; padding: 8px 12px; background: rgba(255,255,255,0.6); backdrop-filter: blur(8px); }
       /* Hide the advanced panel until toggled open via the button */
       #advanced { display: none; }
       #advanced[open] { display: block; }
       /* Hide native summary; we use a toolbar button to toggle */
       summary { display: none; }
       summary::-webkit-details-marker { display: none; }
       details[open] { border-color: rgba(10,132,255,0.25); }
      .brand-fixed {
        position: fixed;
        top: 12px;
        left: 60px;
        z-index: 1000;
        font-weight: 800;
        font-size: 1.5em;
        letter-spacing: 0.4px;
        color: #0b1220;
        background: rgba(255,255,255,0.6);
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        border: 1px solid var(--border);
        padding: 8px 12px;
        border-radius: 12px;
        box-shadow: 0 8px 20px rgba(0,0,0,0.08);
        text-shadow: 0 1px 1px rgba(255,255,255,0.5), 0 1px 2px rgba(0,0,0,0.06);
        user-select: none;
        pointer-events: none;
      }
      .brand-fixed.hidden { opacity: 0; }
      body.dark .brand-fixed { color: #eef4ff; background: rgba(24,28,36,0.48); border-color: rgba(255,255,255,0.14); }

      /* Animated gradient text for brand */
      .brand-text {
        background: linear-gradient(90deg,
          hsl(210, 90%, 55%),
          hsl(280, 90%, 60%),
          hsl(340, 90%, 60%),
          hsl(210, 90%, 55%)
        );
        background-size: 400% 100%;
        -webkit-background-clip: text; background-clip: text;
        color: transparent;
        animation: brandFlow 30s ease-in-out infinite;
        will-change: background-position;
        display: inline-block;
      }
      @keyframes brandFlow {
        0%   { background-position: 0% 50%; }
        50%  { background-position: 100% 50%; }
        100% { background-position: 0% 50%; }
      }
      @media (prefers-reduced-motion: reduce) {
        .brand-text { animation-duration: 60s; }
      }

      /* Fullscreen background video */
      .bg-video { position: fixed; inset: 0; width: 100%; height: 100%; object-fit: cover; z-index: -1; display: none; filter: saturate(1.05) brightness(0.95); }
      body.video-on .bg-video { display: block; }

      /* Dark mode buttons */
      body.dark .btn,
      body.dark .mini-btn,
      body.dark .icon-btn {
        color: #eef3fb;
        border-color: rgba(10,132,255,0.45);
        background: linear-gradient(180deg, rgba(10,132,255,0.32), rgba(10,132,255,0.22));
      }

      /* Dark mode inputs */
      body.dark input[type="text"],
      body.dark textarea,
      body.dark select,
      body.dark input[type="number"] {
        background: rgba(24,26,32,0.92);
        color: #eef3fb;
        border-color: rgba(255,255,255,0.12);
      }

      body.dark select option { color: #0b1220; }

      /* Dark mode conversation backgrounds */
      body.dark .convo { background: rgba(30,34,42,0.72); border-color: rgba(255,255,255,0.10); }
      body.dark .convo[data-empty="true"] { background: transparent; border-color: transparent; }

      body.dark .msg { background: rgba(48,52,60,0.80); border-color: rgba(255,255,255,0.14); }
      body.dark .msg.user { background: rgba(10,132,255,0.18); border-color: rgba(10,132,255,0.35); }
    </style>
  </head>
  <body>
    <video class="bg-video" id="bgVideo" autoplay loop muted playsinline preload="auto" poster="michael-fousert-lE5-z4nTCTQ-unsplash.jpg">
      <source src="bg.webm" type="video/webm" />
      <source src="bg.mp4" type="video/mp4" />
    </video>
    <div class="brand-fixed" id="brand"><span class="brand-text">ü§î Many Answers</span></div>
    <button id="settingsFab" class="settings-fab" title="Settings" aria-label="Settings">‚öôÔ∏è</button>
    <div class="container">
      <div class="answers row" id="answers" style="margin-top:16px; position: relative;">
        <div class="card" id="card-model1">
          <h3>
            <span style="display:inline-flex; align-items:center; gap:8px;">
              <span class="traffic">
                <span class="dot red" id="dot-hide-model1" title="Hide"></span>
                <span class="dot yellow" id="dot-restore-model1" title="Restore"></span>
                <span class="dot green" id="dot-max-model1" title="Maximize"></span>

              </span>
              <select class="model-select" id="select-model1" title="Choose model for this window"></select>
              <div class="title"><span data-text="Model 1" id="model1-name">Model 1</span></div>
              <button class="icon-btn" id="handoff-model1" title="Handoff from active card to this model">Handoff ‚ñ∏</button>
              <button class="icon-btn" id="clear-model1" title="Clear this conversation">Clear</button>
            </span>
            
          </h3>
          <div class="convo" id="model1" data-empty="true" tabindex="0"></div>
          <div class="mini">
            <button id="ask-model1" class="mini-btn">Ask</button>
            <textarea id="follow-model1" class="follow" rows="2" placeholder="Follow up to Model 1‚Ä¶"></textarea>
        </div>
        </div>
        <div class="card" id="card-model2">
          <h3>
            <span style="display:inline-flex; align-items:center; gap:8px;">
              <span class="traffic">
                <span class="dot red" id="dot-hide-model2" title="Hide"></span>
                <span class="dot yellow" id="dot-restore-model2" title="Restore"></span>
                <span class="dot green" id="dot-max-model2" title="Maximize"></span>

              </span>
              <select class="model-select" id="select-model2" title="Choose model for this window"></select>
              <div class="title"><span data-text="Model 2" id="model2-name">Model 2</span></div>
              <button class="icon-btn" id="handoff-model2" title="Handoff from active card to this model">Handoff ‚ñ∏</button>
              <button class="icon-btn" id="clear-model2" title="Clear this conversation">Clear</button>
            </span>
            
          </h3>
          <div class="convo" id="model2" data-empty="true" tabindex="0"></div>
          <div class="mini">
            <button id="ask-model2" class="mini-btn">Ask</button>
            <textarea id="follow-model2" class="follow" rows="2" placeholder="Follow up to Model 2‚Ä¶"></textarea>
          </div>
        </div>
        <div class="card" id="card-model3">
          <h3>
            <span style="display:inline-flex; align-items:center; gap:8px;">
              <span class="traffic">
                <span class="dot red" id="dot-hide-model3" title="Hide"></span>
                <span class="dot yellow" id="dot-restore-model3" title="Restore"></span>
                <span class="dot green" id="dot-max-model3" title="Maximize"></span>

              </span>
              <select class="model-select" id="select-model3" title="Choose model for this window"></select>
              <div class="title"><span data-text="Model 3" id="model3-name">Model 3</span></div>
              <button class="icon-btn" id="handoff-model3" title="Handoff from active card to this model">Handoff ‚ñ∏</button>
              <button class="icon-btn" id="clear-model3" title="Clear this conversation">Clear</button>
            </span>
            
          </h3>
          <div class="convo" id="model3" data-empty="true" tabindex="0"></div>
          <div class="mini">
            <button id="ask-model3" class="mini-btn">Ask</button>
            <textarea id="follow-model3" class="follow" rows="2" placeholder="Follow up to Model 3‚Ä¶"></textarea>
          </div>
        </div>
        <div class="card" id="card-model5" style="display: none;">
          <h3>
            <span style="display:inline-flex; align-items:center; gap:8px;">
              <span class="traffic">
                <span class="dot red" id="dot-hide-model5" title="Hide"></span>
                <span class="dot yellow" id="dot-restore-model5" title="Restore"></span>
                <span class="dot green" id="dot-max-model5" title="Maximize"></span>

              </span>
              <div class="title"><span data-text="Search Model" id="model5-name">Search Model</span></div>
              <button class="icon-btn" id="handoff-model5" title="Handoff from active card to this model">Handoff ‚ñ∏</button>
              <button class="icon-btn" id="clear-model5" title="Clear this conversation">Clear</button>
            </span>
            
          </h3>
          <div class="convo" id="model5" data-empty="true" tabindex="0"></div>
          <div class="mini">
            <button id="ask-model5" class="mini-btn">Ask</button>
            <textarea id="follow-model5" class="follow" rows="2" placeholder="Follow up to Search Model‚Ä¶"></textarea>
          </div>
        </div>
      </div>

      <!-- Prompt section moved to bottom -->
      <div class="panel" id="panel-bottom" style="display:grid; gap:12px; position: fixed;">
        <div class="panel-drag-strip drag-handle" aria-hidden="true"></div>
        <!-- Replaced by global FAB -->
        <div class="prompt-row">
          <div class="left-controls">
            <button id="askBtn" class="btn btn-sm">Ask all</button>
          </div>
          <textarea id="prompt" placeholder="Ask anything..." style="flex:1 1 auto;"></textarea>
          <div class="right-controls">
            <input type="file" id="attachInput" multiple style="display:none" />
            <button id="attachBtn" class="btn btn-sm" title="Attach files to include in your question">üìé Attach</button>
            <button id="handoffAllBtn" class="btn btn-sm" title="Send this turn from the active card to all other enabled models">Handoff all</button>
            <button id="searchToggleBtn" class="btn btn-sm" title="Toggle search mode - when active, all questions use search model">üîç Search</button>
            <button id="deepResearchToggleBtn" class="btn btn-sm" title="Toggle deep research mode - when active, all questions use deep research model">üî¨ GPT Deep</button>

            <button id="geminiResearchToggleBtn" class="btn btn-sm" title="Toggle Gemini Deep (Gemini 2.5 Pro) instructions mode">üíé Gemini Deep</button>
            <button id="superResearchToggleBtn" class="btn btn-sm" title="Super Research - uses GPT Deep and Gemini 2.5 Pro then GPT-4o summarizes into one comprehensive report">üöÄ Super</button>
            <button id="usageMonitorBtn" class="btn btn-sm" title="Open API usage monitor window">üìä API Monitor</button>
            <button id="summarizeBtn" class="btn btn-sm" title="Summarize outputs from current windows into bullet points">üìù Summarize</button>
            <button id="addWindowBtn" class="btn btn-sm" title="Add a new conversation window">‚ûï Add Window</button>
            <button id="resetLayoutBtn" class="btn btn-sm" title="Reset card layout to grid">üîÑ Reset Layout</button>
            <button id="closeAllWindowsBtn" class="btn btn-sm" title="Close all research windows">‚ùå Close All</button>
          </div>
        </div>
        <div id="attachmentList" class="attachments-row" aria-live="polite"></div>
        <!-- Inline control panel kept for structure but hidden; settings open in modal -->
        <div class="control-panel-section" id="controlPanelSection" style="display:none;">
        <div class="row">
          <div>
            <label>Model 1</label>
            <select id="model-1">
              <option value="o3-pro-2025-06-10">o3-pro 2025-06-10</option>
              <option value="o3-2025-04-16">o3 2025-04-16</option>



              <option value="gpt-4o-mini">GPT-4o Mini</option>
              <option value="gpt-4.1">GPT-4.1</option>
              <option value="gpt-4-turbo">GPT-4 Turbo</option>
              <option value="claude-opus-4-1-20250805" selected>Claude Opus 4.1 20250805</option>
              <option value="claude-4.1-opus">Claude Opus 4.1</option>
              <option value="claude-4-sonnet">Claude Sonnet 4</option>
              <option value="claude-3-5-sonnet-latest">Claude 3.5 Sonnet</option>
              <option value="claude-3-opus-latest">Claude 3 Opus</option>
              <option value="claude-3-haiku-latest">Claude 3 Haiku</option>
              <option value="gemini-2.5-pro">Gemini 2.5 Pro</option>
              <option value="gemini-2.5-flash">Gemini 2.5 Flash</option>
              <option value="gemini-1.5-pro">Gemini 1.5 Pro</option>
              <option value="gemini-1.5-flash">Gemini 1.5 Flash</option>
              <option value="gemini-1.5-flash-8b">Gemini 1.5 Flash 8B</option>
            </select>
          </div>
          <div>
            <label>Model 2</label>
            <select id="model-2">
              <option value="">-- Disabled --</option>
              <option value="claude-opus-4-1-20250805">Claude Opus 4.1 20250805</option>
              <option value="o3-pro-2025-06-10">o3-pro 2025-06-10</option>
              <option value="o3-2025-04-16">o3 2025-04-16</option>

              <option value="gpt-5-mini-2025-08-07" selected>GPT-5 Mini</option>

              <option value="gpt-4o-mini">GPT-4o Mini</option>
              <option value="gpt-4.1">GPT-4.1</option>
              <option value="gpt-4-turbo">GPT-4 Turbo</option>
              <option value="claude-opus-4-1-20250805">Claude Opus 4.1 20250805</option>
              <option value="claude-4.1-opus">Claude Opus 4.1</option>
              <option value="claude-4-sonnet">Claude Sonnet 4</option>
              <option value="claude-3-5-sonnet-latest">Claude 3.5 Sonnet</option>
              <option value="claude-3-opus-latest">Claude 3 Opus</option>
              <option value="claude-3-haiku-latest">Claude 3 Haiku</option>
              <option value="gemini-2.5-pro">Gemini 2.5 Pro</option>
              <option value="gemini-2.5-flash">Gemini 2.5 Flash</option>
              <option value="gemini-1.5-pro">Gemini 1.5 Pro</option>
              <option value="gemini-1.5-flash">Gemini 1.5 Flash</option>
              <option value="gemini-1.5-flash-8b">Gemini 1.5 Flash 8B</option>
            </select>
          </div>
          <div>
            <label>Model 3</label>
            <select id="model-3">
              <option value="">-- Disabled --</option>
              <option value="gemini-2.5-pro">Gemini 2.5 Pro</option>
              <option value="o3-pro-2025-06-10">o3-pro 2025-06-10</option>
              <option value="o3-2025-04-16" selected>o3 2025-04-16</option>



              <option value="gpt-4o-mini">GPT-4o Mini</option>
              <option value="gpt-4.1">GPT-4.1</option>
              <option value="gpt-4-turbo">GPT-4 Turbo</option>
              <option value="claude-opus-4-1-20250805">Claude Opus 4.1 20250805</option>
              <option value="claude-4.1-opus">Claude Opus 4.1</option>
              <option value="claude-4-sonnet">Claude Sonnet 4</option>
              <option value="claude-3-5-sonnet-latest">Claude 3.5 Sonnet</option>
              <option value="claude-3-opus-latest">Claude 3 Opus</option>
              <option value="claude-3-haiku-latest">Claude 3 Haiku</option>
              <option value="gemini-2.5-pro">Gemini 2.5 Pro</option>
              <option value="gemini-2.5-flash">Gemini 2.5 Flash</option>
              <option value="gemini-1.5-pro">Gemini 1.5 Pro</option>
              <option value="gemini-1.5-flash">Gemini 1.5 Flash</option>
              <option value="gemini-1.5-flash-8b">Gemini 1.5 Flash 8B</option>
            </select>
          </div>
          <div>
            <label>Search Model</label>
            <select id="model-5">
              <option value="gpt-4o-mini-search-preview-2025-03-11" selected>GPT-4o Mini Search Preview</option>
              <option value="">-- Disabled --</option>
              <option value="claude-opus-4-1-20250805">Claude Opus 4.1 20250805</option>
              <option value="o3-pro-2025-06-10">o3-pro 2025-06-10</option>
              <option value="o3-2025-04-16">o3 2025-04-16</option>
              <option value="gpt-4o-mini">GPT-4o Mini</option>
              <option value="gpt-4.1">GPT-4.1</option>
              <option value="gpt-4-turbo">GPT-4 Turbo</option>
              <option value="claude-4.1-opus">Claude Opus 4.1</option>
              <option value="claude-4-sonnet">Claude Sonnet 4</option>
              <option value="claude-3-5-sonnet-latest">Claude 3.5 Sonnet</option>
              <option value="claude-3-opus-latest">Claude 3 Opus</option>
              <option value="claude-3-haiku-latest">Claude 3 Haiku</option>
              <option value="gemini-2.5-pro">Gemini 2.5 Pro</option>
              <option value="gemini-2.5-flash">Gemini 2.5 Flash</option>
              <option value="gemini-1.5-pro">Gemini 1.5 Pro</option>
              <option value="gemini-1.5-flash">Gemini 1.5 Flash</option>
              <option value="gemini-1.5-flash-8b">Gemini 1.5 Flash 8B</option>
            </select>
          </div>
          <div>
            <label>Deep Research Model</label>
            <select id="model-6">
              <option value="o4-mini-deep-research-2025-06-26" selected>o4 Mini Deep Research 2025-06-26</option>
              <option value="">-- Disabled --</option>
              <option value="o1-deep-research">o1 Deep Research</option>
              <option value="o3-deep-research">o3 Deep Research</option>
              <option value="o3-pro-2025-06-10">o3-pro 2025-06-10</option>
              <option value="o3-2025-04-16">o3 2025-04-16</option>
              <option value="gpt-4o-mini">GPT-4o Mini</option>
              <option value="gpt-4.1">GPT-4.1</option>
              <option value="gpt-4-turbo">GPT-4 Turbo</option>
              <option value="gemini-2.5-pro">Gemini 2.5 Pro</option>
              <option value="gemini-2.5-flash">Gemini 2.5 Flash</option>
              <option value="gemini-1.5-pro">Gemini 1.5 Pro</option>
              <option value="gemini-1.5-flash">Gemini 1.5 Flash</option>
              <option value="gemini-1.5-flash-8b">Gemini 1.5 Flash 8B</option>
            </select>
          </div>

          <div>
            <label>Gemini Model</label>
            <select id="model-8">
              <option value="gemini-2.5-pro" selected>Gemini 2.5 Pro</option>
              <option value="">-- Disabled --</option>
              <option value="gemini-2.0-flash-thinking">Gemini 2.0 Flash Thinking</option>
              <option value="gemini-2.5-flash">Gemini 2.5 Flash</option>
              <option value="gemini-1.5-pro">Gemini 1.5 Pro</option>
              <option value="gemini-1.5-flash">Gemini 1.5 Flash</option>
              <option value="gemini-1.5-flash-8b">Gemini 1.5 Flash 8B</option>
              <option value="o3-pro-2025-06-10">o3-pro 2025-06-10</option>
              <option value="o3-2025-04-16">o3 2025-04-16</option>
              <option value="gpt-4o-mini">GPT-4o Mini</option>
              <option value="gpt-4.1">GPT-4.1</option>
              <option value="gpt-4-turbo">GPT-4 Turbo</option>
            </select>
          </div>
          <div>
            <label>Super Research Summarizer</label>
            <select id="model-9">
              <option value="gpt-4o-mini" selected>GPT-4o Mini</option>
              <option value="gpt-4o">GPT-4o</option>
              <option value="">-- Disabled --</option>
              <option value="gpt-4.1">GPT-4.1</option>
              <option value="gpt-4-turbo">GPT-4 Turbo</option>
              <option value="o3-pro-2025-06-10">o3-pro 2025-06-10</option>
              <option value="o3-2025-04-16">o3 2025-04-16</option>
              <option value="claude-opus-4-1-20250805">Claude Opus 4.1 20250805</option>
              <option value="claude-4.1-opus">Claude Opus 4.1</option>
              <option value="claude-4-sonnet">Claude Sonnet 4</option>
              <option value="claude-3-5-sonnet-latest">Claude 3.5 Sonnet</option>
              <option value="claude-3-opus-latest">Claude 3 Opus</option>
              <option value="claude-3-haiku-latest">Claude 3 Haiku</option>
              <option value="gemini-2.5-pro">Gemini 2.5 Pro</option>
              <option value="gemini-2.5-flash">Gemini 2.5 Flash</option>
              <option value="gemini-1.5-pro">Gemini 1.5 Pro</option>
              <option value="gemini-1.5-flash">Gemini 1.5 Flash</option>
              <option value="gemini-1.5-flash-8b">Gemini 1.5 Flash 8B</option>
            </select>
          </div>
        </div>
        <div class="toolbar" style="margin-top:6px; display:flex; gap:10px; align-items:center; flex-wrap: wrap;">
          <label class="switch"><input type="checkbox" id="toggle-video" /> Dynamic background</label>
          <label class="switch"><input type="checkbox" id="toggle-dark" /> Dark mode</label>
          <input type="file" id="bgUpload" accept="image/*" style="display:none" />
          <button id="bgUploadBtn" class="btn btn-sm">Upload background</button>
          <button id="bgClearBtn" class="btn btn-sm">Clear background</button>
        </div>
        <div class="toolbar">
          <button id="streamBtn" class="btn">Stream Model 1</button>
          <button id="drawBtn" class="btn">Draw Model 1</button>
          <button id="advBtn" class="btn btn-sm">Advanced</button>
          <button id="resetAllBtn" class="btn btn-sm" title="Clear all conversations">Start over</button>

          <label class="switch"><input type="checkbox" id="enable-model1" checked /> Model 1</label>
          <label class="switch"><input type="checkbox" id="enable-model2" checked /> Model 2</label>
          <label class="switch"><input type="checkbox" id="enable-model3" checked /> Model 3</label>
          <label class="switch"><input type="checkbox" id="enable-model5" checked /> Search Model</label>
          <label class="switch"><input type="checkbox" id="show-reasoning" /> Show reasoning</label>

        </div>
        </div> <!-- End control-panel-section -->
        <details id="advanced">
          <div style="margin-top:10px; display:grid; gap:8px;">
            <label for="advancedJson">Advanced JSON per provider</label>
            <textarea id="advancedJson" style="min-height: 150px; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;">{
  "openai": {
    "system": "You are a helpful assistant. Be concise and direct.",
    "temperature": 0.2,
    "maxTokens": 1024,
    "timeoutMs": 30000
  },
  "claude": {
    "system": "You are a helpful assistant. Be concise and direct.",
    "temperature": 0.2,
    "maxTokens": 1024,
    "timeoutMs": 30000
  },
  "gemini": {
    "system": "You are a helpful assistant. Be concise and direct.",
    "temperature": 0.2,
    "maxTokens": 1024,
    "timeoutMs": 30000
  }
}</textarea>
            <small class="small" style="color: var(--muted);">Invalid JSON will be ignored. Keys are optional; unspecified ones keep their previous values.</small>
          </div>
        </details>
      </div>

      <!-- Settings modal -->
      <div id="settingsModal" class="settings-modal" aria-hidden="true">
        <div class="settings-sheet">
          <h3 style="margin-top:0">Settings</h3>
          <div id="settingsBody"></div>
          <div style="display:flex; justify-content:flex-end; gap:8px; margin-top:12px;">
            <button id="closeSettings" class="btn btn-sm">Close</button>
          </div>
        </div>
      </div>
    </div>

    <script>
      const el = (id) => document.getElementById(id);
      const askBtn = el('askBtn');
      const streamBtn = el('streamBtn');
      const drawBtn = el('drawBtn');
      const statusEl = el('status');
      // in-memory conversation histories per model
      window.__histories = window.__histories || { model1: [], model2: [], model3: [], model5: [] };
      const out = {
        model1: el('model1'),
        model2: el('model2'),
        model3: el('model3'),
        model5: el('model5'),
      };
      // Track last active card for handoff purposes
      let __activeCardId = 'model1';
      // Update active card when typing/focusing in follow areas
      ['model1','model2','model3','model5'].forEach((m) => {
        const follow = document.getElementById('follow-' + m);
        if (follow) {
          follow.addEventListener('focus', () => { __activeCardId = m; });
          follow.addEventListener('pointerdown', () => { __activeCardId = m; });
        }
        const card = document.getElementById('card-' + m);
        if (card) {
          card.addEventListener('pointerdown', () => { __activeCardId = m; });
        }
      });
      
      // Helper function to get provider from model
      function getProviderFromModel(modelValue) {
        if (!modelValue) return null;
        if (modelValue.startsWith('gpt-') || modelValue.startsWith('o3-') || modelValue.startsWith('o4-') || modelValue.startsWith('dall-e')) return 'openai';
        if (modelValue.startsWith('claude-')) return 'claude';
        if (modelValue.startsWith('gemini-')) return 'gemini';
        return null;
      }

      // Central list of model options available to per-window dropdowns
      const MODEL_OPTIONS = [
        { value: '', label: '-- Disabled --' },
        // OpenAI
        { value: 'gpt-5-mini-2025-08-07', label: 'GPT-5 Mini' },
        { value: 'o4-mini-deep-research-2025-06-26', label: 'o4 Mini Deep Research 2025-06-26' },
        { value: 'o3-pro-2025-06-10', label: 'o3-pro 2025-06-10' },
        { value: 'o3-2025-04-16', label: 'o3 2025-04-16' },
        { value: 'gpt-4o-mini', label: 'GPT-4o Mini' },
        { value: 'gpt-4.1', label: 'GPT-4.1' },
        { value: 'gpt-4-turbo', label: 'GPT-4 Turbo' },
        { value: 'gpt-4o', label: 'GPT-4o' },
        { value: 'gpt-4o-mini-search-preview-2025-03-11', label: 'GPT-4o Mini Search Preview' },
        // Anthropic
        { value: 'claude-opus-4-1-20250805', label: 'Claude Opus 4.1 20250805' },
        { value: 'claude-4.1-opus', label: 'Claude Opus 4.1' },
        { value: 'claude-4-sonnet', label: 'Claude Sonnet 4' },
        { value: 'claude-3-5-sonnet-latest', label: 'Claude 3.5 Sonnet' },
        { value: 'claude-3-opus-latest', label: 'Claude 3 Opus' },
        { value: 'claude-3-haiku-latest', label: 'Claude 3 Haiku' },
        // Google
        { value: 'gemini-2.5-pro', label: 'Gemini 2.5 Pro' },
        { value: 'gemini-2.5-flash', label: 'Gemini 2.5 Flash' },
        { value: 'gemini-1.5-pro', label: 'Gemini 1.5 Pro' },
        { value: 'gemini-1.5-flash', label: 'Gemini 1.5 Flash' },
        { value: 'gemini-1.5-flash-8b', label: 'Gemini 1.5 Flash 8B' },
      ];

      function populateModelSelect(selectEl, selectedValue) {
        if (!selectEl) return;
        selectEl.innerHTML = '';
        MODEL_OPTIONS.forEach(opt => {
          const o = document.createElement('option');
          o.value = opt.value;
          o.textContent = opt.label;
          selectEl.appendChild(o);
        });
        if (typeof selectedValue === 'string') {
          const exists = Array.from(selectEl.options).some(o => o.value === selectedValue);
          if (exists) selectEl.value = selectedValue;
        }
      }

      function cardTitleSpanFor(modelId) {
        const card = document.getElementById('card-' + modelId);
        return card?.querySelector('.title span') || null;
      }
      function updateCardTitleFromSelect(modelId) {
        const sel = document.getElementById('select-' + modelId);
        const span = cardTitleSpanFor(modelId);
        if (!sel || !span) return;
        const txt = sel.options[sel.selectedIndex]?.text || span.textContent;
        span.textContent = txt.includes('--') ? span.getAttribute('data-text') || span.textContent : txt;
        span.setAttribute('data-text', span.textContent);
      }

      function initBuiltInCardSelect(modelId, settingsSelectId, storageKey) {
        const sel = document.getElementById('select-' + modelId);
        const settingsSel = document.getElementById(settingsSelectId);
        const LS = window.localStorage;
        if (!sel) return;
        const preferred = (LS.getItem(storageKey) || settingsSel?.value || '');
        populateModelSelect(sel, preferred);
        updateCardTitleFromSelect(modelId);
        sel.addEventListener('change', () => {
          const v = sel.value || '';
          try { LS.setItem(storageKey, v); } catch {}
          if (settingsSel) settingsSel.value = v;
          updateCardTitleFromSelect(modelId);
          updateAskButtonText();
        });
      }
      
      // Update model display names when dropdowns change
      function updateModelNames() {
        for (let i = 1; i <= 3; i++) {
          const nameEl = el(`model${i}-name`);
          const perCardSel = el(`select-model${i}`);
          const settingsSel = el(`model-${i}`);
          if (nameEl) {
            const selectedText = perCardSel?.options[perCardSel.selectedIndex]?.text || settingsSel?.options[settingsSel.selectedIndex]?.text || `Model ${i}`;
            nameEl.textContent = selectedText.includes('--') ? `Model ${i}` : selectedText;
            nameEl.setAttribute('data-text', nameEl.textContent);
          }
        }
        // Handle model5 (search model) separately
        const select5 = el('model-5');
        const nameEl5 = el('model5-name');
        if (select5 && nameEl5) {
          const selectedText = select5.options[select5.selectedIndex]?.text || 'Search Model';
          nameEl5.textContent = selectedText.includes('--') ? 'Search Model' : selectedText;
          nameEl5.setAttribute('data-text', nameEl5.textContent);
        }
      }
      
      el('model-1').addEventListener('change', updateModelNames);
      el('model-2').addEventListener('change', updateModelNames);
      el('model-3').addEventListener('change', updateModelNames);
      el('model-5').addEventListener('change', updateModelNames);
      el('model-6').addEventListener('change', updateModelNames);

      // Persistence: remember last selected models and toggles in localStorage
      const LS = window.localStorage;
      function setSelectIfPresent(selectId, value) {
        const sel = el(selectId);
        if (!sel || typeof value !== 'string' || !value) return;
        const exists = Array.from(sel.options).some((opt) => opt.value === value);
        if (exists) sel.value = value;
      }
      function restorePreferences() {
        // Models
        setSelectIfPresent('model-1', LS.getItem('ma:model-1'));
        setSelectIfPresent('model-2', LS.getItem('ma:model-2'));
        setSelectIfPresent('model-3', LS.getItem('ma:model-3'));
        setSelectIfPresent('model-5', LS.getItem('ma:model-5'));
        setSelectIfPresent('model-6', LS.getItem('ma:model-6'));
        // Toggles
        const e1 = LS.getItem('ma:enable-model1'); if (e1 !== null) el('enable-model1').checked = e1 === '1';
        const e2 = LS.getItem('ma:enable-model2'); if (e2 !== null) el('enable-model2').checked = e2 === '1';
        const e3 = LS.getItem('ma:enable-model3'); if (e3 !== null) el('enable-model3').checked = e3 === '1';
        const e5 = LS.getItem('ma:enable-model5'); if (e5 !== null) el('enable-model5').checked = e5 === '1';
        const sr = LS.getItem('ma:show-reasoning'); if (sr !== null) el('show-reasoning').checked = sr === '1';
        const dv = LS.getItem('ma:video'); if (dv !== null) { const on = dv === '1'; el('toggle-video').checked = on; /* enable video after it becomes ready; keep image until then */ }
        const dk = LS.getItem('ma:dark'); if (dk !== null) { const on = dk === '1'; el('toggle-dark').checked = on; document.body.classList.toggle('dark', on); }
        // Advanced JSON (optional)
        const advArea = document.getElementById('advancedJson');
        const advSaved = LS.getItem('ma:advancedJson');
        if (advArea && typeof advSaved === 'string' && advSaved.length) advArea.value = advSaved;
        // Apply visuals after restoring
        updateModelNames();
        applyVisibility();
      }
      function wirePersistence() {
        // Model selects
        el('model-1').addEventListener('change', () => { const v = el('model-1').value || ''; LS.setItem('ma:model-1', v); const s = el('select-model1'); if (s) s.value = v; updateModelNames(); updateAskButtonText(); });
        el('model-2').addEventListener('change', () => { const v = el('model-2').value || ''; LS.setItem('ma:model-2', v); const s = el('select-model2'); if (s) s.value = v; updateModelNames(); updateAskButtonText(); });
        el('model-3').addEventListener('change', () => { const v = el('model-3').value || ''; LS.setItem('ma:model-3', v); const s = el('select-model3'); if (s) s.value = v; updateModelNames(); updateAskButtonText(); });
        el('model-5').addEventListener('change', () => { LS.setItem('ma:model-5', el('model-5').value || ''); updateAskButtonText(); });
        el('model-6').addEventListener('change', () => { LS.setItem('ma:model-6', el('model-6').value || ''); updateAskButtonText(); });
        // Toggles
        el('enable-model1').addEventListener('change', () => { LS.setItem('ma:enable-model1', el('enable-model1').checked ? '1' : '0'); updateAskButtonText(); });
        el('enable-model2').addEventListener('change', () => { LS.setItem('ma:enable-model2', el('enable-model2').checked ? '1' : '0'); updateAskButtonText(); });
        el('enable-model3').addEventListener('change', () => { LS.setItem('ma:enable-model3', el('enable-model3').checked ? '1' : '0'); updateAskButtonText(); });
        el('enable-model5').addEventListener('change', () => { LS.setItem('ma:enable-model5', el('enable-model5').checked ? '1' : '0'); updateAskButtonText(); });
        el('show-reasoning').addEventListener('change', () => LS.setItem('ma:show-reasoning', el('show-reasoning').checked ? '1' : '0'));
        // Advanced JSON
        const advArea = document.getElementById('advancedJson');
        if (advArea) {
          let advTimer = null;
          advArea.addEventListener('input', () => {
            if (advTimer) clearTimeout(advTimer);
            advTimer = setTimeout(() => LS.setItem('ma:advancedJson', advArea.value || ''), 250);
          });
        }
        // New toggles
        const tv = el('toggle-video');
        const td = el('toggle-dark');
        function applyVideoToggle(on) {
          const video = document.getElementById('bgVideo');
          LS.setItem('ma:video', on ? '1' : '0');
          if (!video) return;
          if (on) {
            const show = () => { document.body.classList.add('video-on'); };
            if (video.readyState >= 2) show(); else video.addEventListener('loadeddata', show, { once: true });
            video.play?.().catch(() => {});
          } else {
            document.body.classList.remove('video-on');
            video.pause?.();
          }
        }
        if (tv) tv.addEventListener('change', () => { const on = tv.checked; applyVideoToggle(on); });
        if (td) td.addEventListener('change', () => { const on = td.checked; document.body.classList.toggle('dark', on); LS.setItem('ma:dark', on ? '1' : '0'); });
        // Background upload
        const upBtn = document.getElementById('bgUploadBtn');
        const clrBtn = document.getElementById('bgClearBtn');
        const upInp = document.getElementById('bgUpload');
        function applyBg(url) {
          try {
            LS.setItem('ma:bg-image', url || '');
          } catch {}
          if (url) {
            document.body.style.backgroundImage = `url('${url}')`;
            document.body.classList.remove('video-on');
            if (tv) tv.checked = false;
          } else {
            document.body.style.backgroundImage = "url('michael-fousert-lE5-z4nTCTQ-unsplash.jpg')";
          }
        }
        if (upBtn && upInp) {
          upBtn.addEventListener('click', () => upInp.click());
          upInp.addEventListener('change', (e) => {
            const file = e.target.files && e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = () => applyBg(reader.result);
            reader.readAsDataURL(file);
          });
        }
        if (clrBtn) clrBtn.addEventListener('click', () => applyBg(''));
        // Restore custom bg if any
        const savedBg = LS.getItem('ma:bg-image');
        if (savedBg) applyBg(savedBg);
        // If user had video enabled previously, enable it only after it's ready
        const wantVideo = LS.getItem('ma:video') === '1';
        if (wantVideo) applyVideoToggle(true);
      }
      restorePreferences();
      wirePersistence();
      updateModelNames();

      // Initialize per-window model dropdowns for built-in cards
      initBuiltInCardSelect('model1', 'model-1', 'ma:model-1');
      initBuiltInCardSelect('model2', 'model-2', 'ma:model-2');
      initBuiltInCardSelect('model3', 'model-3', 'ma:model-3');

      // ----- Layout persistence (drag positions) -----
      function layoutStorageKey() { return 'ma:layout'; }
      function hasSavedLayout() { return !!LS.getItem(layoutStorageKey()); }
      function saveLayoutForCard(cardId, spec) {
        let current = null;
        try { current = JSON.parse(LS.getItem(layoutStorageKey()) || '{}'); } catch {}
        if (!current || typeof current !== 'object') current = {};
        if (!current.cards) current.cards = {};
        current.cards[cardId] = spec;
        LS.setItem(layoutStorageKey(), JSON.stringify(current));
      }
      function applySavedLayout() {
        let saved = null;
        try { saved = JSON.parse(LS.getItem(layoutStorageKey()) || 'null'); } catch {}
        if (!saved || !saved.cards) return;
        const container = document.getElementById('answers');
        if (!container) return;
        
        // Switch to isolated layout if we have any saved positions
        container.classList.add('isolated');
        
        ['card-model1','card-model2','card-model3','card-model5'].forEach((id) => {
          const spec = saved.cards[id];
          const card = document.getElementById(id);
          if (!card || !spec) return;
          
          // Make all cards absolutely positioned in isolated mode
          card.style.position = 'absolute';
          card.style.left = (spec.left ?? 0) + 'px';
          card.style.top = (spec.top ?? 0) + 'px';
          card.style.width = (spec.width ?? 400) + 'px';
          card.style.height = (spec.height ?? 300) + 'px';
          card.style.zIndex = String(spec.zIndex ?? 1);
        });
        
        updateIsolatedLayout();
      }
      function clearSavedLayout() {
        LS.removeItem(layoutStorageKey());
        const container = document.getElementById('answers');
        if (!container) return;
        container.classList.remove('isolated');
        container.style.minHeight = '';
        ['card-model1','card-model2','card-model3','card-model5'].forEach((id) => {
          const card = document.getElementById(id);
          if (!card) return;
          card.style.position = '';
          card.style.left = '';
          card.style.top = '';
          card.style.width = '';
          card.style.height = '';
          card.style.zIndex = '';
        });
      }

      // Reset layout to equal columns for the currently visible cards
      function resetEqualLayout() {
        try { LS.removeItem(layoutStorageKey()); } catch {}
        const answers = document.getElementById('answers');
        if (!answers) return;
        
        // Exit isolated/custom/single modes
        answers.classList.remove('isolated', 'custom-layout', 'single');

        // Clear inline positions for all cards
        const allCards = Array.from(answers.querySelectorAll('.card'));
        allCards.forEach((card) => {
          card.style.position = '';
          card.style.left = '';
          card.style.top = '';
          card.style.width = '';
          card.style.height = '';
          card.style.zIndex = '';
          card.classList.remove('maximized','minimized');
        });

        // Reset answers container to default grid layout
        answers.style.position = '';
        answers.style.left = '';
        answers.style.right = '';
        answers.style.top = '';
        answers.style.width = '';
        answers.style.height = '';
        answers.style.maxWidth = '';
        answers.style.transform = '';
        answers.style.alignItems = '';
        answers.style.padding = '';
        answers.style.margin = '';
        answers.style.minHeight = '';

        // Determine visible cards and set grid columns
        const visibleCards = allCards.filter((c) => {
          const cs = window.getComputedStyle(c);
          return cs.display !== 'none' && cs.visibility !== 'hidden';
        });
        const count = Math.max(1, visibleCards.length);
        answers.style.gridTemplateColumns = `repeat(${count}, 1fr)`;
        answers.style.gap = '8px';
        
        // Set fixed height for cards
        visibleCards.forEach((card) => {
          card.style.height = '580px'; // Fixed height
          card.style.minHeight = '';
          card.style.maxHeight = '';
        });
      }
      function updateContainerHeightForLayout() {
        const container = document.getElementById('answers');
        if (!container || !container.classList.contains('custom-layout')) return;
        const cards = ['card-model1','card-model2','card-model3','card-model5']
          .map((id) => document.getElementById(id))
          .filter(Boolean);
        let maxBottom = 0;
        cards.forEach((c) => {
          const top = parseFloat(c.style.top) || 0;
          const rect = c.getBoundingClientRect();
          const height = rect.height || 0;
          const bottom = top + height;
          if (bottom > maxBottom) maxBottom = bottom;
        });
        container.style.height = Math.max(420, Math.ceil(maxBottom + 16)) + 'px';
      }

      // Restore saved layouts on page load
      applySavedLayout();
      // Keep container height in sync when window resizes
      window.addEventListener('resize', updateIsolatedLayout);

      // Save all current absolute positions back to storage (for safety on reloads)
      function saveAllLayouts() {
        const container = document.getElementById('answers');
        if (!container || !container.classList.contains('custom-layout')) return;
        const current = { cards: {} };
        ['card-model1','card-model2','card-model3','card-model5'].forEach((id) => {
          const card = document.getElementById(id);
          if (!card) return;
          const left = parseFloat(card.style.left);
          const top = parseFloat(card.style.top);
          const width = parseFloat(card.style.width);
          const height = parseFloat(card.style.height);
          const zIndex = parseInt(card.style.zIndex);
          if (!Number.isFinite(left) || !Number.isFinite(top) || !Number.isFinite(width)) return;
          current.cards[id] = { 
            left: Math.round(left), 
            top: Math.round(top), 
            width: Math.round(width),
            height: Number.isFinite(height) ? Math.round(height) : undefined,
            zIndex: Number.isFinite(zIndex) ? zIndex : 1
          };
        });
        try { LS.setItem(layoutStorageKey(), JSON.stringify(current)); } catch {}
      }
      window.addEventListener('beforeunload', saveAllLayouts);

      // Reset helper: restore default 1-2-1 grid
      function clearSavedColumns() {
        const answers = document.getElementById('answers');
        if (answers) answers.style.gridTemplateColumns = '1fr 2fr 1fr';
      }
      
      // Reasoning helpers (for thinking models like OpenAI o3*)
      function isThinkingModel(modelValue) {
        if (!modelValue) return false;
        return /^o3(\b|[-_])/.test(modelValue) || /o3-pro/.test(modelValue);
      }
      function withBriefReasoning(baseSystem, modelValue, enabled) {
        if (!enabled && !isThinkingModel(modelValue)) return baseSystem || '';
        const base = baseSystem ? baseSystem + '\n' : '';
        return (
          base +
          "First provide a very brief reasoning section (1-3 short bullets, max ~400 characters) prefixed with 'Reasoning:', then on a new line provide 'Answer:' with the final concise answer."
        );
      }
      // Spark management per model
      const __sparkTimers = { model1: null, model2: null, model3: null };
      const SPARK_EMOJIS = ['‚ú®','üí´','‚≠êÔ∏è','üåü','üíñ','üíö','üíô','üíú','üß°','üíõ','üíó','üí•','üíû','üíì','üíò','ü™Ñ','üéá','üéÜ'];
      function emitSparkFor(card) {
        const titleSpan = card.querySelector('.title span');
        if (!titleSpan) return;
        const spark = document.createElement('span');
        spark.className = 'spark';
        spark.textContent = SPARK_EMOJIS[Math.floor(Math.random() * SPARK_EMOJIS.length)];
        // random horizontal offset and slight random duration tweak via CSS var
        const x = (Math.random() * 120 - 60).toFixed(0) + 'px';
        spark.style.setProperty('--x', x);
        spark.style.fontSize = (12 + Math.random() * 12).toFixed(0) + 'px';
        spark.style.setProperty('--rot', (Math.random()*40 - 20).toFixed(0) + 'deg');
        spark.style.setProperty('--d', (0.9 + Math.random()*0.8).toFixed(2) + 's');
        titleSpan.appendChild(spark);
        spark.addEventListener('animationend', () => spark.remove());
      }
      function startSparks(modelId) { /* disabled visual sparks in subtle mode */ }
      function stopSparks(modelId) { const t = __sparkTimers[modelId]; if (t) { clearInterval(t); __sparkTimers[modelId] = null; } }
      function setLoading(modelId, loading) {
        const card = document.getElementById(`card-${modelId}`);
        if (!card) return;
        if (loading) {
          card.classList.add('loading');
          // Randomize blob positions per session for partial coverage
          const b1x = (20 + Math.random() * 60).toFixed(1) + '%';
          const b1y = (20 + Math.random() * 60).toFixed(1) + '%';
          const b2x = (20 + Math.random() * 60).toFixed(1) + '%';
          const b2y = (20 + Math.random() * 60).toFixed(1) + '%';
          card.style.setProperty('--b1x', b1x);
          card.style.setProperty('--b1y', b1y);
          card.style.setProperty('--b2x', b2x);
          card.style.setProperty('--b2y', b2y);
        } else {
          card.classList.remove('loading');
        }
        if (loading) {
          // Set hue once per card; keep afterwards
          let hue = card.dataset.hue;
          if (!hue) {
            hue = Math.floor(Math.random() * 360);
            card.dataset.hue = hue;
          }
          card.style.setProperty('--tint-h', hue);
          card.classList.remove('tinted');
          startSparks(modelId);
        } else {
          card.classList.add('tinted');
          stopSparks(modelId);
        }
      }

      // Hide/show cards and adjust grid based on model toggles
      function applyVisibility() {
        const vis = {
          model1: document.getElementById('enable-model1').checked,
          model2: document.getElementById('enable-model2').checked,
          model3: document.getElementById('enable-model3').checked,
          model5: document.getElementById('enable-model5').checked,
        };
        const answers = document.getElementById('answers');
        const visibleCount = Object.values(vis).filter(Boolean).length;

        if (!answers.classList.contains('isolated')) {
          if (visibleCount === 1) {
            answers.style.gridTemplateColumns = '1fr';
          } else if (visibleCount === 2) {
            answers.style.gridTemplateColumns = '1fr 1fr';
          } else {
            answers.style.gridTemplateColumns = '1fr 2fr 1fr';
          }
        }
        
        document.getElementById('card-model1').style.display = vis.model1 ? '' : 'none';
        document.getElementById('card-model2').style.display = vis.model2 ? '' : 'none';
        document.getElementById('card-model3').style.display = vis.model3 ? '' : 'none';
        document.getElementById('card-model5').style.display = 'none'; // Always hidden - search model works behind the scenes
        updateAskButtonText();
      }
      document.getElementById('enable-model1').addEventListener('change', applyVisibility);
      document.getElementById('enable-model2').addEventListener('change', applyVisibility);
      document.getElementById('enable-model3').addEventListener('change', applyVisibility);
      document.getElementById('enable-model5').addEventListener('change', applyVisibility);
      
      // Update ask button text based on enabled models
      function updateAskButtonText() {
        const enabledModels = ['model1','model2','model3','model5'].filter(m => {
          const perCard = el(`select-${m}`);
          const fallback = el(`model-${m.slice(-1)}`);
          return el(`enable-${m}`).checked && ((perCard && perCard.value) || (fallback && fallback.value));
        });
        const askBtn = document.getElementById('askBtn');
        if (askBtn) {
          askBtn.textContent = enabledModels.length === 1 ? 'Ask it' : 'Ask all';
        }
      }
      applyVisibility();
      // Re-apply saved layout after visibility adjustments
      applySavedLayout();
      // Initial button text update
      updateAskButtonText();

      // Hide/Maximize/Restore
      let __prevVisibility = null;
      function checkboxFor(modelId) { return document.getElementById(`enable-${modelId}`); }
      function hideModel(modelId) {
        const cb = checkboxFor(modelId);
        if (cb) { cb.checked = false; applyVisibility(); }
      }
      function maximizeModel(modelId) {
        const targetCard = document.getElementById('card-' + modelId);
        if (targetCard && targetCard.classList.contains('minimized')) {
          // If minimized, restore to previous normal state
          targetCard.classList.remove('minimized');
          return;
        }
        __prevVisibility = {
          model1: checkboxFor('model1').checked,
          model2: checkboxFor('model2').checked,
          model3: checkboxFor('model3').checked,
          model5: checkboxFor('model5').checked,
        };
        checkboxFor('model1').checked = modelId === 'model1';
        checkboxFor('model2').checked = modelId === 'model2';
        checkboxFor('model3').checked = modelId === 'model3';
        checkboxFor('model5').checked = modelId === 'model5';
        applyVisibility();
        // Switch answers area to single mode and enlarge selected (preserve isolated positions)
        const answers = document.getElementById('answers');
        answers.classList.add('single');
        ['model1','model2','model3'].forEach((m) => {
          const card = document.getElementById('card-' + m);
          if (!card) return;
          const isTarget = modelId === m;
          if (isTarget) {
            // Save current inline geometry for later restore
            card.dataset.prevPosition = card.style.position || '';
            card.dataset.prevLeft = card.style.left || '';
            card.dataset.prevTop = card.style.top || '';
            card.dataset.prevWidth = card.style.width || '';
            card.dataset.prevHeight = card.style.height || '';
            card.dataset.prevZ = card.style.zIndex || '';
            // Clear to allow CSS .card.maximized to take full width/height
          card.style.position = '';
          card.style.left = '';
          card.style.top = '';
          card.style.width = '';
            card.style.height = '';
            // keep zIndex cleared so stacking doesn't block others when exiting
          card.style.zIndex = '';
          }
          card.classList.toggle('maximized', isTarget);
        });
        // Hide brand for full utilization and scroll to the card
        document.getElementById('brand').classList.add('hidden');
        const maximizedCard = document.getElementById(`card-${modelId}`);
        document.body.classList.add('max-on');
        // scroll prompt panel out of view so card fills page
        const topPanel = document.getElementById('panel-top');
        const y = topPanel.offsetTop + topPanel.offsetHeight + 8;
        window.scrollTo({ top: y, behavior: 'smooth' });
      }
      // Click on yellow dot now minimizes if normal; if maximized, restore
      document.getElementById('dot-restore-model1').addEventListener('click', () => {
        const c = document.getElementById('card-model1');
        if (c && c.classList.contains('maximized')) return restoreAll();
        if (c) c.classList.toggle('minimized');
      });
      document.getElementById('dot-restore-model2').addEventListener('click', () => {
        const c = document.getElementById('card-model2');
        if (c && c.classList.contains('maximized')) return restoreAll();
        if (c) c.classList.toggle('minimized');
      });
      document.getElementById('dot-restore-model3').addEventListener('click', () => {
        const c = document.getElementById('card-model3');
        if (c && c.classList.contains('maximized')) return restoreAll();
        if (c) c.classList.toggle('minimized');
      });
      document.getElementById('dot-restore-model5').addEventListener('click', () => {
        const c = document.getElementById('card-model5');
        if (c && c.classList.contains('maximized')) return restoreAll();
        if (c) c.classList.toggle('minimized');
      });
      function restoreAll() {
        if (!__prevVisibility) return;
        const answers = document.getElementById('answers');
        answers.classList.remove('single');
        ['model1','model2','model3'].forEach((m) => {
          const card = document.getElementById('card-' + m);
          if (!card) return;
          // Restore geometry if we saved it during maximize
          if (card.dataset.prevPosition !== undefined) {
            card.style.position = card.dataset.prevPosition;
            card.style.left = card.dataset.prevLeft;
            card.style.top = card.dataset.prevTop;
            card.style.width = card.dataset.prevWidth;
            card.style.height = card.dataset.prevHeight;
            card.style.zIndex = card.dataset.prevZ;
            delete card.dataset.prevPosition;
            delete card.dataset.prevLeft;
            delete card.dataset.prevTop;
            delete card.dataset.prevWidth;
            delete card.dataset.prevHeight;
            delete card.dataset.prevZ;
          }
          card.classList.remove('maximized');
        });
        checkboxFor('model1').checked = __prevVisibility.model1;
        checkboxFor('model2').checked = __prevVisibility.model2;
        checkboxFor('model3').checked = __prevVisibility.model3;
        checkboxFor('model5').checked = __prevVisibility.model5;
        applyVisibility();
        __prevVisibility = null;
        document.getElementById('brand').classList.remove('hidden');
        document.body.classList.remove('max-on');
        // If isolated layout was never initialized, just reset grid like a safe fallback
        const answersHadIsolated = document.getElementById('answers').classList.contains('isolated');
        if (!answersHadIsolated) {
          clearSavedLayout();
          clearSavedColumns();
        }
      }



      // Draggable cards (for free positioning); kept in case user prefers manual layout
      function makeDraggable(cardId) {
        const card = document.getElementById(cardId);
        if (!card) return;
        const handle = card; // use the whole card as drag handle, with guards below
        let dragging = false, startX = 0, startY = 0, startLeft = 0, startTop = 0;
        function isInteractive(el) { return !!el.closest('input, textarea, select, button, .mini, .convo, .drag-handle'); }
        function onPointerDown(e) {
          if (isInteractive(e.target)) return;
          
          // Initialize isolated mode for all cards if not already done
          initializeAllCardsForIsolation();
          
          dragging = true;
          const rect = card.getBoundingClientRect();
          startLeft = rect.left;
          startTop = rect.top;
          startX = e.clientX || (e.touches && e.touches[0]?.clientX) || 0;
          startY = e.clientY || (e.touches && e.touches[0]?.clientY) || 0;
          card.style.position = 'fixed';
          card.style.left = `${startLeft}px`;
          card.style.top = `${startTop}px`;
          card.style.width = `${rect.width}px`;
          card.style.zIndex = 2000;
          document.addEventListener('pointermove', onPointerMove);
          document.addEventListener('pointerup', onPointerUp);
          document.addEventListener('touchmove', onPointerMove, { passive: false });
          document.addEventListener('touchend', onPointerUp);
        }
        function onPointerMove(e) {
          if (!dragging) return;
          const x = e.clientX || (e.touches && e.touches[0]?.clientX) || 0;
          const y = e.clientY || (e.touches && e.touches[0]?.clientY) || 0;
          const dx = x - startX;
          const dy = y - startY;
          card.style.left = `${startLeft + dx}px`;
          card.style.top = `${startTop + dy}px`;
          if (e.cancelable) e.preventDefault();
        }
        function onPointerUp() {
          dragging = false;
          document.removeEventListener('pointermove', onPointerMove);
          document.removeEventListener('pointerup', onPointerUp);
          document.removeEventListener('touchmove', onPointerMove);
          document.removeEventListener('touchend', onPointerUp);
          // Convert fixed drag position into absolute position within the answers container and persist
          const container = document.getElementById('answers');
          if (!container) return;
          container.classList.add('isolated');
          
          const rect = card.getBoundingClientRect();
          const containerRect = container.getBoundingClientRect();
          const left = rect.left - containerRect.left + (container.scrollLeft || 0);
          const top = rect.top - containerRect.top + (container.scrollTop || 0);
          
          card.style.position = 'absolute';
          card.style.left = `${Math.max(0, Math.round(left))}px`;
          card.style.top = `${Math.max(0, Math.round(top))}px`;
          card.style.width = `${Math.round(rect.width)}px`;
          card.style.zIndex = '1';
          
          const spec = getCurrentCardSpec(cardId);
          if (spec) {
            saveLayoutForCard(cardId, spec);
          }
          updateIsolatedLayout();
          card.classList.remove('dragging');
        }
        handle.addEventListener('pointerdown', onPointerDown);
        handle.addEventListener('touchstart', onPointerDown, { passive: true });
        // Also add four corner drag handles for explicit dragging
        ['tl','tr','bl','br'].forEach((pos) => {
          const h = document.createElement('div');
          h.className = `drag-handle ${pos}`;
          card.appendChild(h);
          h.addEventListener('pointerdown', (e) => {
            dragging = true;
            const rect = card.getBoundingClientRect();
            startLeft = rect.left;
            startTop = rect.top;
            startX = e.clientX || (e.touches && e.touches[0]?.clientX) || 0;
            startY = e.clientY || (e.touches && e.touches[0]?.clientY) || 0;
            card.style.position = 'fixed';
            card.style.left = `${startLeft}px`;
            card.style.top = `${startTop}px`;
            card.style.width = `${rect.width}px`;
            card.style.zIndex = 2000;
            card.classList.add('dragging');
            document.addEventListener('pointermove', onPointerMove);
            document.addEventListener('pointerup', onPointerUp);
            document.addEventListener('touchmove', onPointerMove, { passive: false });
            document.addEventListener('touchend', onPointerUp);
            e.stopPropagation();
            e.preventDefault();
          });
        });
      }

      // Bring clicked card to front
      function bringToFront(cardId) {
        const card = document.getElementById(cardId);
        if (!card) return;
        // mark active
        if (cardId.startsWith('card-')) {
          __activeCardId = cardId.replace('card-', '');
        }
        
        // Find the highest z-index among all cards
        const allCards = ['card-model1', 'card-model2', 'card-model3', 'card-model5'];
        let maxZ = 0;
        allCards.forEach(id => {
          const c = document.getElementById(id);
          if (c && c.style.zIndex) {
            const z = parseInt(c.style.zIndex) || 0;
            if (z > maxZ) maxZ = z;
          }
        });
        
        // Set this card's z-index higher than the max
        card.style.zIndex = String(maxZ + 1);
        
        // Save the updated z-index
        const currentSpec = getCurrentCardSpec(cardId);
        if (currentSpec) {
          currentSpec.zIndex = maxZ + 1;
          saveLayoutForCard(cardId, currentSpec);
        }
      }
      
      // Get current card specifications
      function getCurrentCardSpec(cardId) {
        const card = document.getElementById(cardId);
        if (!card) return null;
        
        return {
          left: parseFloat(card.style.left) || 0,
          top: parseFloat(card.style.top) || 0,
          width: parseFloat(card.style.width) || 240,
          height: parseFloat(card.style.height) || 200,
          zIndex: parseInt(card.style.zIndex) || 1
        };
      }

      // Make cards completely isolated - resizable and positionable independently
      function makeResizable(cardId) {
        const card = document.getElementById(cardId);
        if (!card) return;
        
        // Add click-to-front functionality (but only if already in isolated mode)
        card.addEventListener('pointerdown', () => {
          const container = document.getElementById('answers');
          if (container && container.classList.contains('isolated')) {
            bringToFront(cardId);
          }
        });
        card.addEventListener('click', () => {
          const container = document.getElementById('answers');
          if (container && container.classList.contains('isolated')) {
            bringToFront(cardId);
          }
        });
        
        // Add resize handles
        const handles = ['n','s','w','e','nw','ne','sw','se'];
        handles.forEach(dir => {
          const handle = document.createElement('div');
          handle.className = `resize-handle resize-${dir}`;
          card.appendChild(handle);
          
          handle.addEventListener('pointerdown', (e) => {
            e.preventDefault();
            e.stopPropagation();
            
            // Initialize isolated mode for all cards if not already done
            initializeAllCardsForIsolation();
            
            const startX = e.clientX;
            const startY = e.clientY;
            const startRect = card.getBoundingClientRect();
            const container = document.getElementById('answers');
            const containerRect = container.getBoundingClientRect();
            
            function onMove(e) {
              const dx = e.clientX - startX;
              const dy = e.clientY - startY;
              
              let newWidth = startRect.width;
              let newHeight = startRect.height;
              let newLeft = startRect.left - containerRect.left;
              let newTop = startRect.top - containerRect.top;
              
              // Calculate new dimensions and position based on direction
              if (dir.includes('e')) newWidth = Math.max(240, startRect.width + dx);
              if (dir.includes('w')) { 
                newWidth = Math.max(240, startRect.width - dx); 
                newLeft = Math.max(0, (startRect.left - containerRect.left) + dx);
              }
              if (dir.includes('s')) newHeight = Math.max(200, startRect.height + dy);
              if (dir.includes('n')) { 
                newHeight = Math.max(200, startRect.height - dy); 
                newTop = Math.max(0, (startRect.top - containerRect.top) + dy);
              }
              
              // Apply changes immediately
              card.style.width = `${newWidth}px`;
              card.style.height = `${newHeight}px`;
              card.style.left = `${newLeft}px`;
              card.style.top = `${newTop}px`;
            }
            
            function onUp() {
              document.removeEventListener('pointermove', onMove);
              document.removeEventListener('pointerup', onUp);
              
              // Save the final state
              const spec = getCurrentCardSpec(cardId);
              if (spec) {
                saveLayoutForCard(cardId, spec);
                updateIsolatedLayout();
              }
            }
            
            document.addEventListener('pointermove', onMove);
            document.addEventListener('pointerup', onUp);
          });
        });
      }
      
      // Initialize all cards for isolated positioning when first interaction happens
      function initializeAllCardsForIsolation() {
        const container = document.getElementById('answers');
        if (!container) return;
        // Only initialize if not already in isolated mode
        if (container.classList.contains('isolated')) return;

        const allCards = ['card-model1', 'card-model2', 'card-model3', 'card-model5'];
        // Capture rectangles BEFORE changing layout
        const preRects = {};
        allCards.forEach((cardId) => {
          const card = document.getElementById(cardId);
          if (!card) return;
          preRects[cardId] = card.getBoundingClientRect();
        });

        // Switch to isolated layout
        container.classList.add('isolated');
        // Rect after layout change (for relative offsets)
        const containerRect = container.getBoundingClientRect();

        // Apply absolute positions using the pre-change rectangles
        allCards.forEach((cardId, index) => {
          const card = document.getElementById(cardId);
          const rect = preRects[cardId];
          if (!card || !rect) return;
          card.style.position = 'absolute';
          card.style.left = `${Math.max(0, Math.round(rect.left - containerRect.left))}px`;
          card.style.top = `${Math.max(0, Math.round(rect.top - containerRect.top))}px`;
          card.style.width = `${Math.round(rect.width)}px`;
          card.style.height = `${Math.round(rect.height)}px`;
          // preserve existing z-index if any, else assign stacking by order
          if (!card.style.zIndex) card.style.zIndex = String(index + 1);
        });
      }
      
      // Initialize a single card for isolated positioning (legacy function)
      function initializeIsolatedCard(cardId) {
        initializeAllCardsForIsolation();
      }
      
      // Update isolated layout container height
      function updateIsolatedLayout() {
        const container = document.getElementById('answers');
        if (!container || !container.classList.contains('isolated')) return;
        
        const cards = ['card-model1','card-model2','card-model3','card-model5']
          .map((id) => document.getElementById(id))
          .filter(Boolean);
        
        let maxBottom = 500; // minimum height
        cards.forEach((card) => {
          const top = parseFloat(card.style.top) || 0;
          const height = parseFloat(card.style.height) || 200;
          const bottom = top + height;
          if (bottom > maxBottom) maxBottom = bottom;
        });
        
        container.style.minHeight = `${Math.ceil(maxBottom + 20)}px`;
      }

      // Auto-resize prompt textarea (no dock coupling)
      const promptTextarea = document.getElementById('prompt');
      if (promptTextarea) {
        function autoResize() {
          promptTextarea.style.height = 'auto';
          const maxH = 140; // hard cap
          promptTextarea.style.height = Math.min(maxH, Math.max(40, promptTextarea.scrollHeight)) + 'px';
        }
        promptTextarea.addEventListener('input', autoResize);
        promptTextarea.addEventListener('paste', () => setTimeout(autoResize, 0));
        // Enter to submit (Shift+Enter inserts newline)
        promptTextarea.addEventListener('keydown', (e) => {
          if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            const btn = document.getElementById('askBtn');
            if (btn && !btn.disabled) btn.click();
          }
        });
        autoResize();
      }
      
      // Make the prompt panel draggable and resizable, independent from cards
      (function makePromptPanelFloating() {
        const panel = document.getElementById('panel-bottom');
        if (!panel) return;
        let dragging = false, startX = 0, startY = 0, startLeft = 0, startTop = 0;
        function onDown(e) {
          const target = e.target;
          if (!target.classList.contains('panel-drag-strip')) return;
          const rect = panel.getBoundingClientRect();
          dragging = true;
          startLeft = rect.left;
          startTop = rect.top;
          startX = e.clientX || (e.touches && e.touches[0]?.clientX) || 0;
          startY = e.clientY || (e.touches && e.touches[0]?.clientY) || 0;
          panel.style.left = startLeft + 'px';
          panel.style.top = startTop + 'px';
          panel.style.transform = 'none';
          panel.style.right = 'auto';
          panel.style.bottom = 'auto';
          document.addEventListener('pointermove', onMove);
          document.addEventListener('pointerup', onUp);
          document.addEventListener('touchmove', onMove, { passive: false });
          document.addEventListener('touchend', onUp);
        }
        function onMove(e) {
          if (!dragging) return;
          const x = e.clientX || (e.touches && e.touches[0]?.clientX) || 0;
          const y = e.clientY || (e.touches && e.touches[0]?.clientY) || 0;
          const dx = x - startX;
          const dy = y - startY;
          panel.style.left = startLeft + dx + 'px';
          panel.style.top = startTop + dy + 'px';
          if (e.cancelable) e.preventDefault();
        }
        function onUp() {
          dragging = false;
          document.removeEventListener('pointermove', onMove);
          document.removeEventListener('pointerup', onUp);
          document.removeEventListener('touchmove', onMove);
          document.removeEventListener('touchend', onUp);
          persistPromptPanel();
        }
        panel.addEventListener('pointerdown', onDown);
        panel.addEventListener('touchstart', onDown, { passive: true });

        // Resizer (bottom-right grip)
        const resizer = document.createElement('div');
        resizer.style.position = 'absolute';
        resizer.style.right = '6px';
        resizer.style.bottom = '6px';
        resizer.style.width = '14px';
        resizer.style.height = '14px';
        resizer.style.cursor = 'nwse-resize';
        resizer.style.borderRadius = '4px';
        resizer.className = 'prompt-resizer';
        panel.appendChild(resizer);
        let resizing = false, startW = 0, startH = 0;
        resizer.addEventListener('pointerdown', (e) => {
          e.preventDefault(); e.stopPropagation();
          const rect = panel.getBoundingClientRect();
          resizing = true;
          startX = e.clientX; startY = e.clientY;
          startW = rect.width; startH = rect.height;
          document.addEventListener('pointermove', onResize);
          document.addEventListener('pointerup', onResizeEnd);
        });
        function onResize(e) {
          if (!resizing) return;
          const dx = e.clientX - startX; const dy = e.clientY - startY;
          panel.style.width = Math.max(420, startW + dx) + 'px';
          panel.style.height = Math.max(160, startH + dy) + 'px';
          persistPromptPanel();
        }
        function onResizeEnd() {
          resizing = false;
          document.removeEventListener('pointermove', onResize);
          document.removeEventListener('pointerup', onResizeEnd);
          persistPromptPanel();
        }

        // Persistence
        const LS = window.localStorage;
        function persistPromptPanel() {
          const rect = panel.getBoundingClientRect();
          const state = { left: rect.left, top: rect.top, width: rect.width, height: rect.height };
          LS.setItem('ma:prompt-panel', JSON.stringify(state));
        }
        function restorePromptPanel() {
          try {
            const raw = LS.getItem('ma:prompt-panel');
            if (!raw) return;
            const s = JSON.parse(raw);
            if (s && typeof s === 'object') {
              panel.style.transform = 'none';
              panel.style.left = (s.left ?? 40) + 'px';
              panel.style.top = (s.top ?? (window.innerHeight - (s.height ?? 220) - 24)) + 'px';
              if (s.width) panel.style.width = s.width + 'px';
              if (s.height) panel.style.height = s.height + 'px';
            }
          } catch {}
        }
        restorePromptPanel();
      })();


      // Control panel toggle
      // Settings modal wiring
      const settingsFab = document.getElementById('settingsFab');
      const settingsModal = document.getElementById('settingsModal');
      const settingsBody = document.getElementById('settingsBody');
      const closeSettings = document.getElementById('closeSettings');
      const controlPanelSection = document.getElementById('controlPanelSection');
      // Keep original location so events stay wired; move node in/out of modal
      let __settingsPlaceholder = null;
      let __settingsOriginalParent = null;
      if (controlPanelSection) {
        __settingsOriginalParent = controlPanelSection.parentElement;
        __settingsPlaceholder = document.createComment('settings-placeholder');
        if (__settingsOriginalParent) {
          __settingsOriginalParent.insertBefore(__settingsPlaceholder, controlPanelSection.nextSibling);
        }
      }
      function openSettings() {
        if (!settingsModal || !settingsBody || !controlPanelSection) return;
        // Move the real section so all existing listeners keep working
        controlPanelSection.style.display = '';
        settingsBody.textContent = '';
        settingsBody.appendChild(controlPanelSection);
        settingsModal.classList.add('open');
        settingsModal.setAttribute('aria-hidden', 'false');
      }
      function closeSettingsModal() {
        if (!settingsModal || !controlPanelSection) return;
        settingsModal.classList.remove('open');
        settingsModal.setAttribute('aria-hidden', 'true');
        // Move settings back and hide inline
        if (__settingsPlaceholder && __settingsPlaceholder.parentNode) {
          __settingsPlaceholder.parentNode.insertBefore(controlPanelSection, __settingsPlaceholder);
          controlPanelSection.style.display = 'none';
        }
      }
      if (settingsFab) settingsFab.addEventListener('click', openSettings);
      if (closeSettings) closeSettings.addEventListener('click', closeSettingsModal);
      if (settingsModal) settingsModal.addEventListener('click', (e) => { if (e.target === settingsModal) closeSettingsModal(); });

      ['card-model1','card-model2','card-model3'].forEach(makeDraggable);
      ['card-model1','card-model2','card-model3'].forEach(makeResizable);
      // Always reset to equal layout on page load
      (function resetLayoutOnPageLoad() {
        resetEqualLayout(); // Auto-reset layout on page load
      })();
      async function ask() {
        console.log('Frontend: Before ask(), window.__histories:', window.__histories);
        
        // If search mode is active, use search model for all enabled models
        if (searchModeActive) {
          const searchModelValue = el('model-5').value;
          if (!searchModelValue) {
            alert('Search model is not configured. Please select a search model in settings.');
            return;
          }
          ensureResearchCardVisibleWithName(el('model-5').options[el('model-5').selectedIndex]?.text || 'Search Model');
        }
        
        // If deep research mode is active, use deep research model for all enabled models
        if (deepResearchModeActive) {
          const deepResearchModelValue = el('model-6').value;
          if (!deepResearchModelValue) {
            alert('Deep research model is not configured. Please select a deep research model in settings.');
            return;
          }
          ensureResearchCardVisibleWithName(el('model-6').options[el('model-6').selectedIndex]?.text || 'GPT Deep');
        }
        

        
        // If Gemini research mode is active, use Gemini research model for all enabled models
        if (geminiResearchModeActive) {
          const geminiResearchModelValue = el('model-8').value;
          if (!geminiResearchModelValue) {
            alert('Gemini research model is not configured. Please select a Gemini research model in settings.');
            return;
          }
          ensureResearchCardVisibleWithName(el('model-8').options[el('model-8').selectedIndex]?.text || 'Gemini');
        }
        
        // If Super mode is active, we will auto-summarize after Ask completes (no early return)
        if (superResearchModeActive) {
          // no-op here; handled post completion
        }
        
        const enabledModels = ['model1','model2','model3'].filter(m => {
          const perCard = el(`select-${m}`);
          const fallback = el(`model-${m.slice(-1)}`);
          return el(`enable-${m}`).checked && ((perCard && perCard.value) || (fallback && fallback.value));
        });
        if (enabledModels.length === 0) return;

        askBtn.disabled = true;
        enabledModels.forEach(m => setLoading(m, true));

        const adv = parseAdvanced();
        const promptText = el('prompt').value;
        const showReasoning = el('show-reasoning').checked;

        const jobs = enabledModels.map(async (modelId) => {
          const idx = modelId.slice(-1);
          // Use special models if mode is active, otherwise use the model's configured value
          let modelValue;
          if (searchModeActive) {
            modelValue = el('model-5').value;
          } else if (deepResearchModeActive) {
            modelValue = el('model-6').value;

          } else if (geminiResearchModeActive) {
            modelValue = el('model-8').value;
          } else {
            const perCard = el(`select-model${idx}`);
            modelValue = (perCard && perCard.value) || el(`model-${idx}`).value;
          }
          const provider = getProviderFromModel(modelValue);
          if (!provider) return;

          try {
            const res = await fetch('/api/ask', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                prompt: promptText,
                system: withBriefReasoning((adv[provider]?.system ?? adv.system) ?? '', modelValue, showReasoning),
                histories: window.__histories,
                modelId,
                providers: { [provider]: true },
                models: { [provider]: modelValue },
                temperature: (adv[provider]?.temperature ?? adv.temperature) ?? 0.2,
                maxTokens: (adv[provider]?.maxTokens ?? adv.maxTokens) ?? 1024,
                timeoutMs: (adv[provider]?.timeoutMs ?? adv.timeoutMs) ?? 30000,
              }),
            });
            const data = await res.json();
            const r = data[provider];
            console.log(`Frontend: ${modelId} response:`, r);
            if (r?.ok) {
              const box = out[modelId];
              const u = document.createElement('div'); u.className = 'msg user'; u.textContent = promptText;
              const a = document.createElement('div'); a.className = 'msg assistant'; a.textContent = r.text || '';
              box.appendChild(u); box.appendChild(a); box.dataset.empty = 'false';
              
              // Smart scroll for "Ask all": show question + start of answer
              if (box.children.length > 2) {
                u.scrollIntoView({ behavior: 'smooth', block: 'center' });
              } else {
                box.scrollTop = box.scrollHeight;
              }
              window.__histories[modelId].push(
                { role: 'user', content: promptText },
                { role: 'assistant', content: r.text || '' }
              );
              console.log(`Frontend: Added to ${modelId} history, now ${window.__histories[modelId].length} items`);
            } else {
              const box = out[modelId];
              const errDiv = document.createElement('div');
              errDiv.className = 'msg error';
              errDiv.textContent = r?.error || 'Error';
              box.appendChild(errDiv);
              box.dataset.empty = 'false';
            }
          } catch (err) {
            console.error(`Error with ${modelId}:`, err);
            const box = out[modelId];
            const errDiv = document.createElement('div');
            errDiv.className = 'msg error';
            errDiv.textContent = 'Network error';
            box.appendChild(errDiv);
            box.dataset.empty = 'false';
          } finally {
            setLoading(modelId, false);
          }
        });

        try {
          await Promise.allSettled(jobs);
        } finally {
          askBtn.disabled = false;
        }
        // Auto-summarize after all enabled models have responded when Super mode is on
        if (superResearchModeActive) {
          // Slight delay to allow DOM to render appended answers smoothly, then trigger Summarize
          setTimeout(() => {
            const btn = document.getElementById('summarizeBtn');
            if (btn) btn.click();
          }, 50);
        }
      }
      askBtn.addEventListener('click', ask);
      
      // Stream Model 1 if it's an OpenAI model
      async function askStream() {
        if (!streamBtn) return;
        const model1Value = (el('select-model1')?.value) || el('model-1').value;
        const provider = getProviderFromModel(model1Value);
        if (provider !== 'openai') {
          alert('Streaming is only available for OpenAI models. Please select an OpenAI model for Model 1.');
          return;
        }
        
        streamBtn.disabled = true;
        setLoading('model1', true);
        const adv = parseAdvanced();
        const body = {
          prompt: el('prompt').value,
          system: withBriefReasoning((adv.openai?.system ?? adv.system) ?? '', model1Value, el('show-reasoning')?.checked),
          model: model1Value,
          temperature: (adv.openai?.temperature ?? adv.temperature) ?? 0.2,
          maxTokens: (adv.openai?.maxTokens ?? adv.maxTokens),
          maxCompletionTokens: (adv.openai?.max_completion_tokens ?? adv.max_completion_tokens) ?? 1024,
          histories: window.__histories,
          modelId: 'model1',
        };
        const res = await fetch('/api/stream', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(body) });
        if (!res.body) return ask();
        const reader = res.body.getReader();
        const decoder = new TextDecoder();

        const box = out.model1;
        box.dataset.empty = 'false';
        const promptText = el('prompt').value;
        const u = document.createElement('div'); u.className = 'msg user'; u.textContent = promptText; box.appendChild(u);
        const a = document.createElement('div'); a.className = 'msg assistant'; box.appendChild(a);
        
        // Position view to show question + start of streaming answer
        if (box.children.length > 2) {
          u.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }

        let accumulated = '';
        let buffer = '';
        try {
          while (true) {
            const { value, done } = await reader.read();
            if (done) break;
            buffer += decoder.decode(value, { stream: true });
            const events = buffer.split('\n\n');
            buffer = events.pop();
            for (const evt of events) {
              if (!evt.startsWith('data:')) continue;
              const json = evt.slice(5).trim();
              try {
                const msg = JSON.parse(json);
                if (msg.delta) { 
                  accumulated += msg.delta;
                  a.textContent = accumulated; 
                  // Don't auto-scroll during streaming - let user read from context
                }
                if (msg.done) { 
                  
                  // Add to conversation history
                  window.__histories.model1.push(
                    { role: 'user', content: promptText },
                    { role: 'assistant', content: accumulated }
                  );
                }
              } catch {}
            }
          }
        } catch (err) {
          a.innerHTML = '<span class="error">Streaming error: ' + (err?.message || err) + '</span>';
        } finally {
          streamBtn.disabled = false;
          setLoading('model1', false);
        }
      }
      // Wire up Stream button
      if (streamBtn) streamBtn.addEventListener('click', askStream);
      
      // Ctrl/Cmd+Shift+Enter to stream OpenAI
      document.addEventListener('keydown', (e) => {
        if ((e.metaKey || e.ctrlKey) && e.shiftKey && e.key === 'Enter') askStream();
      });
      if (drawBtn) drawBtn.addEventListener('click', async () => {
        try {
          drawBtn.disabled = true;
          const res = await fetch('/api/draw', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ prompt: el('prompt').value, size: '1024x1024' }),
          });
          const data = await res.json();
          if (data?.ok && data.image) {
            const img = new Image();
            img.src = data.image;
            img.style.maxWidth = '100%';
            img.style.borderRadius = '10px';
            const box = out.model1;
            const u = document.createElement('div'); u.className = 'msg user'; u.textContent = el('prompt').value;
            const a = document.createElement('div'); a.className = 'msg assistant'; a.appendChild(img);
            box.appendChild(u); box.appendChild(a); box.scrollTop = box.scrollHeight; box.dataset.empty = 'false';
          } else {
            alert(data?.error || 'Failed to draw image');
          }
        } finally {
          drawBtn.disabled = false;
        }
      });
      document.addEventListener('keydown', (e) => {
        if ((e.metaKey || e.ctrlKey) && e.key === 'Enter') ask();
      });

      // Advanced button toggles details
      const advBtn = document.getElementById('advBtn');
      const advDetails = document.getElementById('advanced');
      if (advBtn && advDetails) {
        // ensure hidden on load
        advDetails.open = false;
        advBtn.addEventListener('click', () => {
          advDetails.open = !advDetails.open;
        });
      }

      // Parse advanced JSON textarea safely
      function parseAdvanced() {
        const t = document.getElementById('advancedJson');
        if (!t) return {};
        try {
          const data = JSON.parse(t.value || '{}');
          return typeof data === 'object' && data ? data : {};
        } catch (_) { return {}; }
      }

      async function askSingle(modelId) {
        // Use special models if mode is active, otherwise use the model's configured value
        let modelValue;
        if (searchModeActive) {
          modelValue = el('model-5').value;
        } else if (deepResearchModeActive) {
          modelValue = el('model-6').value;
        } else {
          const perCard = el(`select-${modelId}`) || el(`select-model${modelId.slice(-1)}`);
          modelValue = (perCard && perCard.value) || el(`model-${modelId.slice(-1)}`).value;
        }
        if (!modelValue) return;
        const provider = getProviderFromModel(modelValue);
        if (!provider) return;
        
        askBtn.disabled = true;
        setLoading(modelId, true);
        const promptMain = el('prompt').value;
        const followInput = el('follow-' + modelId);
        const followText = followInput ? followInput.value.trim() : '';
        const usePrompt = followText || promptMain;
        const showReasoning = el('show-reasoning').checked;
        try {
          const adv = parseAdvanced();
          console.log(`Frontend: Before request, ${modelId} history has ${window.__histories[modelId]?.length || 0} items`);
          const body = {
            prompt: usePrompt,
            system: withBriefReasoning((adv[provider]?.system ?? adv.system) ?? '', modelValue, showReasoning),
            histories: window.__histories,
            modelId,
            providers: {
              [provider]: true,
            },
            models: {
              [provider]: modelValue,
            },
            temperature: (adv[provider]?.temperature ?? adv.temperature) ?? 0.2,
            maxTokens: (adv[provider]?.maxTokens ?? adv.maxTokens),
            maxCompletionTokens: (adv[provider]?.max_completion_tokens ?? adv.max_completion_tokens) ?? 1024,
            timeoutMs: (adv[provider]?.timeoutMs ?? adv.timeoutMs) ?? 30000,
            showReasoning: showReasoning,
          };
          const res = await fetch('/api/ask', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(body),
          });
          const data = await res.json();
          const r = data[provider];
          if (r?.ok) {
            const box = out[modelId];
            const u = document.createElement('div'); u.className = 'msg user'; u.textContent = usePrompt;
            const a = document.createElement('div'); a.className = 'msg assistant'; a.textContent = r.text || '';
              box.appendChild(u); box.appendChild(a); box.dataset.empty = 'false';
              
              // Clear follow-up input if it was used
              if (followText && followInput) followInput.value = '';
              
              // Smart scroll: show some context + new question + start of answer
              if (box.children.length > 2) {
                // Scroll to show the new question (not the very bottom)
                u.scrollIntoView({ behavior: 'smooth', block: 'center' });
              } else {
                // First conversation, normal scroll
                box.scrollTop = box.scrollHeight;
              }
              
            const latEl = document.getElementById('lat-' + modelId);
            if (latEl) latEl.textContent = `${r.latencyMs} ms`;
            window.__histories[modelId].push(
              { role: 'user', content: usePrompt },
              { role: 'assistant', content: r.text || '' }
            );
            console.log(`Frontend: After adding to ${modelId} history, now ${window.__histories[modelId].length} items`);
          } else {
            out[modelId].innerHTML = '<span class="error">' + (r?.error || 'Error') + '</span>';
            const latEl = document.getElementById('lat-' + modelId);
            if (latEl) latEl.textContent = '';
          }
        } catch (err) {
          console.error(`Error in askSingle(${modelId}):`, err);
        } finally {
          askBtn.disabled = false;
          setLoading(modelId, false);
        }
      }

      // Handoff helpers
      function getLastTurn(modelId) {
        const h = window.__histories?.[modelId];
        if (!Array.isArray(h) || h.length === 0) return null;
        // Find last user message (and its following assistant if available)
        let userIdx = -1;
        for (let i = h.length - 1; i >= 0; i--) {
          if (h[i]?.role === 'user') { userIdx = i; break; }
        }
        if (userIdx < 0) return null;
        const turn = { user: h[userIdx]?.content || '', assistant: '' };
        if (userIdx + 1 < h.length && h[userIdx + 1]?.role === 'assistant') turn.assistant = h[userIdx + 1].content || '';
        // Include prior context up to userIdx - 1
        const context = h.slice(0, userIdx).map(x => ({ role: x.role, content: x.content }));
        return { ...turn, context };
      }
      async function handoffTo(targetModelId, fromModelId) {
        const turn = getLastTurn(fromModelId);
        if (!turn) return;
        const idx = targetModelId.slice(-1);
        const perCard = el(`select-model${idx}`);
        const modelValue = (perCard && perCard.value) || el(`model-${idx}`).value;
        if (!modelValue) return;
        const provider = getProviderFromModel(modelValue);
        if (!provider) return;
        const adv = parseAdvanced();
        const showReasoning = el('show-reasoning').checked;
        // Build a merged histories object: copy current histories, but for target model inject context
        const mergedHistories = JSON.parse(JSON.stringify(window.__histories || {}));
        if (!Array.isArray(mergedHistories[targetModelId])) mergedHistories[targetModelId] = [];
        // Only inject context if target is empty to avoid duplicating conversations
        if (mergedHistories[targetModelId].length === 0 && Array.isArray(turn.context)) {
          mergedHistories[targetModelId].push(...turn.context);
        }
        const body = {
          prompt: turn.user, // resend the last question
          system: withBriefReasoning((adv[provider]?.system ?? adv.system) ?? '', modelValue, showReasoning),
          histories: mergedHistories, // includes source context copied into target
          modelId: targetModelId,
          providers: { [provider]: true },
          models: { [provider]: modelValue },
          temperature: (adv[provider]?.temperature ?? adv.temperature) ?? 0.2,
          maxTokens: (adv[provider]?.maxTokens ?? adv.maxTokens) ?? 1024,
          timeoutMs: (adv[provider]?.timeoutMs ?? adv.timeoutMs) ?? 30000,
          showReasoning,
        };
        setLoading(targetModelId, true);
        try {
          const res = await fetch('/api/ask', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(body) });
          const data = await res.json();
          const r = data[provider];
          const box = out[targetModelId];
          if (r?.ok) {
            const u = document.createElement('div'); u.className = 'msg user'; u.textContent = turn.user;
            const a = document.createElement('div'); a.className = 'msg assistant'; a.textContent = r.text || '';
            box.appendChild(u); box.appendChild(a); box.dataset.empty = 'false';
            window.__histories[targetModelId].push({ role: 'user', content: turn.user }, { role: 'assistant', content: r.text || '' });
            u.scrollIntoView({ behavior: 'smooth', block: 'center' });
          } else {
            const errDiv = document.createElement('div'); errDiv.className = 'msg error'; errDiv.textContent = r?.error || 'Error';
            box.appendChild(errDiv); box.dataset.empty = 'false';
          }
        } catch (err) {
          const box = out[targetModelId];
          const errDiv = document.createElement('div'); errDiv.className = 'msg error'; errDiv.textContent = 'Network error';
          box.appendChild(errDiv); box.dataset.empty = 'false';
        } finally {
          setLoading(targetModelId, false);
        }
      }
      async function handoffAllFrom(fromModelId) {
        const enabled = ['model1','model2','model3']
          .filter(m => el(`enable-${m}`).checked && el(`model-${m.slice(-1)}`).value);
        const targets = enabled.filter(m => m !== fromModelId);
        if (targets.length === 0) return;
        await Promise.allSettled(targets.map(m => handoffTo(m, fromModelId)));
      }

      const btnModel1 = document.getElementById('ask-model1');
      const btnModel2 = document.getElementById('ask-model2');
      const btnModel3 = document.getElementById('ask-model3');
      const btnModel5 = document.getElementById('ask-model5');
      if (btnModel1) btnModel1.addEventListener('click', () => askSingle('model1'));
      if (btnModel2) btnModel2.addEventListener('click', () => askSingle('model2'));
      if (btnModel3) btnModel3.addEventListener('click', () => askSingle('model3'));
      if (btnModel5) btnModel5.addEventListener('click', () => askSingle('model5'));
      // Enter-to-send on follow-up inputs (Shift+Enter for newline)
      const f1 = document.getElementById('follow-model1');
      const f2 = document.getElementById('follow-model2');
      const f3 = document.getElementById('follow-model3');
      const f5 = document.getElementById('follow-model5');
      if (f1) f1.addEventListener('keydown', (e) => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); askSingle('model1'); } });
      if (f2) f2.addEventListener('keydown', (e) => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); askSingle('model2'); } });
      if (f3) f3.addEventListener('keydown', (e) => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); askSingle('model3'); } });
      if (f5) f5.addEventListener('keydown', (e) => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); askSingle('model5'); } });

      // Track research windows by type
      const researchWindows = {
        gpt: new Set(),
        gemini: new Set()
      };

      // Update button state based on window existence
      function updateResearchButtonStates() {
        const deepBtn = document.getElementById('deepResearchToggleBtn');
        const geminiBtn = document.getElementById('geminiResearchToggleBtn');
        
        if (deepBtn) {
          const hasWindows = researchWindows.gpt.size > 0;
          deepBtn.style.backgroundColor = hasWindows ? '#ff6b35' : '';
          deepBtn.style.color = hasWindows ? 'white' : '';
        }
        if (geminiBtn) {
          const hasWindows = researchWindows.gemini.size > 0;
          geminiBtn.style.backgroundColor = hasWindows ? '#34a853' : '';
          geminiBtn.style.color = hasWindows ? 'white' : '';
        }
      }

      // Close all windows of a specific research type
      function closeResearchWindows(type) {
        const windowIds = Array.from(researchWindows[type]);
        windowIds.forEach(uid => {
          const card = document.getElementById('card-' + uid);
          if (card) card.remove();
          researchWindows[type].delete(uid);
          delete out[uid];
          delete window.__histories[uid];
        });
        updateResearchButtonStates();
      }

      // Create a brand-new research conversation card (never reuses old one)
      function openResearchCard(providerKey, modelValue, label) {
        const titleText = label || providerKey.toUpperCase() + ' Research';
        const uid = openGeneralCard(modelValue, titleText, true, providerKey);
        // Update button states  
        updateResearchButtonStates();
        return uid;
      }

      // Close a single research window
      function closeResearchWindow(uid, windowType) {
        const card = document.getElementById('card-' + uid);
        if (card) card.remove();
        if (windowType && researchWindows[windowType]) {
          researchWindows[windowType].delete(uid);
        }
        delete out[uid];
        delete window.__histories[uid];
        updateResearchButtonStates();
        resetEqualLayout(); // Auto-reset layout when closing windows
      }

      // Make closeResearchWindow globally accessible
      window.closeResearchWindow = closeResearchWindow;

      // Ask to the model selected in a card's dropdown
      function askToSelectedModelCard(targetId) {
        const sel = document.getElementById('select-' + targetId);
        if (!sel) return;
        const modelValue = sel.value;
        const providerKey = getProviderFromModel(modelValue);
        if (!providerKey) return;
        askToProviderCard(targetId, providerKey, modelValue);
      }

      // General-purpose dynamic window creation
      function openGeneralCard(defaultModel, label, isResearch = false, providerKey = null) {
        const answers = document.getElementById('answers');
        const uid = (isResearch ? 'research_' : 'win_') + Date.now();
        const cardId = 'card-' + uid;
        const convoId = uid;
        const followId = 'follow-' + uid;
        const askBtnId = 'ask-' + uid;
        const clearBtnId = 'clear-' + uid;
        const selectId = 'select-' + uid;
        const titleText = label || (isResearch ? 'Research Window' : 'New Window');
        
        // Track research windows
        const windowType = isResearch && providerKey ? (() => {
          const typeMap = { openai: 'gpt', gemini: 'gemini' };
          return typeMap[providerKey];
        })() : null;
        
        if (windowType) researchWindows[windowType].add(uid);
        
        const html = `
          <div class="card" id="${cardId}"${isResearch ? ` data-research-type="${windowType}"` : ''}>
            <h3>
              <span style="display:inline-flex; align-items:center; gap:8px;">
                <span class="traffic">
                  <span class="dot red" title="${isResearch ? 'Hide' : 'Close'}" onclick="${isResearch ? `closeResearchWindow('${uid}', '${windowType}')` : `closeWindow('${uid}')`}"></span>
                  <span class="dot yellow" title="${isResearch ? 'Restore' : 'Minimize'}" onclick="document.getElementById('${cardId}').classList.toggle('minimized');"></span>
                  ${isResearch ? `<span class="dot green" title="Maximize" onclick="maximizeModel('${uid}')"></span>` : ''}
                </span>
                <select class="model-select" id="${selectId}" title="Choose model for this window"></select>
                <div class="title"><span data-text="${titleText}">${titleText}</span></div>
                <button class="icon-btn" id="${clearBtnId}" title="Clear this conversation">Clear</button>
              </span>
            </h3>
            <div class="convo" id="${convoId}" data-empty="true" tabindex="0"></div>
            <div class="mini">
              <button id="${askBtnId}" class="mini-btn">Ask</button>
              <textarea id="${followId}" class="follow" rows="2" placeholder="Follow up${isResearch ? ` to ${titleText}` : ''}‚Ä¶"></textarea>
            </div>
          </div>`;
        const wrapper = document.createElement('div');
        wrapper.innerHTML = html;
        const card = wrapper.firstElementChild;
        answers.appendChild(card);
        out[uid] = document.getElementById(convoId);
        window.__histories[uid] = window.__histories[uid] || [];

        // Populate model select
        const sel = document.getElementById(selectId);
        populateModelSelect(sel, defaultModel || 'gpt-5-mini-2025-08-07');
        if (sel) sel.addEventListener('change', () => updateCardTitleFromSelect(uid));
        updateCardTitleFromSelect(uid);

        // Wire clear
        document.getElementById(clearBtnId)?.addEventListener('click', () => {
          out[uid].innerHTML = '';
          out[uid].dataset.empty = 'true';
          window.__histories[uid] = [];
        });
        // Wire ask - research windows may use specific provider, others use selected model
        document.getElementById(askBtnId)?.addEventListener('click', () => askToSelectedModelCard(uid));
        const f = document.getElementById(followId);
        if (f) {
          if (isResearch && providerKey) {
            f.addEventListener('keydown', (e) => { 
              if (e.key === 'Enter' && !e.shiftKey) { 
                e.preventDefault(); 
                const selectedModel = document.getElementById(selectId)?.value;
                askToProviderCard(uid, providerKey, selectedModel); 
              } 
            });
          } else {
            f.addEventListener('keydown', (e) => { 
              if (e.key === 'Enter' && !e.shiftKey) { 
                e.preventDefault(); 
                askToSelectedModelCard(uid); 
              } 
            });
          }
        }

        makeDraggable(cardId);
        makeResizable(cardId);
        resetEqualLayout(); // Auto-reset layout when adding windows
        __activeCardId = uid;
        return uid;
      }

      function closeWindow(uid) {
        const card = document.getElementById('card-' + uid);
        if (card) card.remove();
        delete out[uid];
        delete window.__histories[uid];
        resetEqualLayout(); // Auto-reset layout when closing windows
      }

      async function askToProviderCard(targetId, providerKey, modelValue) {
        if (!providerKey || !modelValue) return;
        const box = out[targetId];
        if (!box) return;
        const follow = document.getElementById('follow-' + targetId);
        const followText = follow ? follow.value.trim() : '';
        const promptMain = el('prompt')?.value || '';
        let promptText = followText || promptMain;
        if (!promptText) return;
        
        // Keep the original prompt for Gemini Deep, but modify the system message instead
        let customSystem = null;
        if (providerKey === 'gemini') {
          customSystem = `You will be given a research task by a user. Your job is to produce a set of
instructions for a researcher that will complete the task. Do NOT complete the
task yourself, just provide instructions on how to complete it.

GUIDELINES:
1. **Maximize Specificity and Detail**
- Include all known user preferences and explicitly list key attributes or
  dimensions to consider.
- It is of utmost importance that all details from the user are included in
  the instructions.

2. **Fill in Unstated But Necessary Dimensions as Open-Ended**
- If certain attributes are essential for a meaningful output but the user
  has not provided them, explicitly state that they are open-ended or default
  to no specific constraint.

3. **Avoid Unwarranted Assumptions**
- If the user has not provided a particular detail, do not invent one.
- Instead, state the lack of specification and guide the researcher to treat
  it as flexible or accept all possible options.

4. **Use the First Person**
- Phrase the request from the perspective of the user.

5. **Tables**
- If you determine that including a table will help illustrate, organize, or
  enhance the information in the research output, you must explicitly request
  that the researcher provide them (examples: product comparison, project
  tracking, budget planning, competitor analysis).

6. **Headers and Formatting**
- Include the expected output format in the prompt.
- If the user is asking for content that would be best returned in a
  structured format (e.g. a report, plan, etc.), ask the researcher to format
  as a report with the appropriate headers and formatting that ensures clarity
  and structure.

7. **Language**
- If the user input is in a language other than English, tell the researcher
  to respond in this language, unless the user query explicitly asks for the
  response in a different language.

8. **Sources**
- If specific sources should be prioritized, specify them in the prompt.
- For product and travel research, prefer linking directly to official or
  primary websites.
- For academic or scientific queries, prefer linking directly to the original
  paper or journal publication.
- If the query is in a specific language, prioritize sources published in that
  language.

You are a helpful assistant. Be concise and direct.`;
        }
        
        const adv = parseAdvanced();
        const body = {
          prompt: promptText,
          system: customSystem || withBriefReasoning((adv[providerKey]?.system ?? adv.system) ?? '', modelValue, false),
          providers: { [providerKey]: true },
          models: { [providerKey]: modelValue },
          histories: window.__histories,
          modelId: targetId,
          temperature: (adv[providerKey]?.temperature ?? adv.temperature) ?? 0.2,
          maxTokens: (adv[providerKey]?.maxTokens ?? adv.maxTokens) ?? 1024,
          timeoutMs: (adv[providerKey]?.timeoutMs ?? adv.timeoutMs) ?? 30000,
          showReasoning: false,
        };
        setLoading(targetId, true);
        try {
          const res = await fetch('/api/ask', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(body) });
          const data = await res.json();
          const r = data[providerKey];
          const u = document.createElement('div'); u.className = 'msg user'; u.textContent = promptText; box.appendChild(u);
          const a = document.createElement('div'); a.className = 'msg assistant'; a.textContent = r?.ok ? (r.text || '') : (r?.error || 'Error'); box.appendChild(a);
          box.dataset.empty = 'false'; box.scrollTop = box.scrollHeight;
          // Update history
          const hist = window.__histories[targetId] || (window.__histories[targetId] = []);
          hist.push({ role: 'user', content: promptText }, { role: 'assistant', content: a.textContent });
          if (follow) follow.value = '';
        } catch (err) {
          const a = document.createElement('div'); a.className = 'msg assistant'; a.textContent = 'Error: ' + (err?.message || err); box.appendChild(a); box.scrollTop = box.scrollHeight;
        } finally {
          setLoading(targetId, false);
        }
      }


      // Auto-grow follow textareas up to 5 lines and never exceed card width
      function autoGrowFollow(el) {
        const computed = window.getComputedStyle(el);
        const lineHeight = parseFloat(computed.lineHeight) || 18;
        const padTop = parseFloat(computed.paddingTop) || 6;
        const padBottom = parseFloat(computed.paddingBottom) || 6;
        const minLines = 2;
        const maxLines = 5;
        const minH = Math.round(lineHeight * minLines + padTop + padBottom);
        const maxH = Math.round(lineHeight * maxLines + padTop + padBottom);
        el.style.height = 'auto';
        const scrollH = el.scrollHeight;
        el.style.height = Math.min(Math.max(scrollH, minH), maxH) + 'px';
      }
      [f1, f2, f3, f5].forEach((el, i) => {
        if (!el) return;
        el.addEventListener('input', () => autoGrowFollow(el));
        // Ensure width never exceeds its container
        el.style.maxWidth = '100%';
        autoGrowFollow(el);
      });
      // Wire Handoff buttons per card
      const handoff1 = document.getElementById('handoff-model1');
      const handoff2 = document.getElementById('handoff-model2');
      const handoff3 = document.getElementById('handoff-model3');
      const handoff5 = document.getElementById('handoff-model5');
      // Handoff per card: from active card to this specific model
      if (handoff1) handoff1.addEventListener('click', () => handoffTo('model1', __activeCardId));
      if (handoff2) handoff2.addEventListener('click', () => handoffTo('model2', __activeCardId));
      if (handoff3) handoff3.addEventListener('click', () => handoffTo('model3', __activeCardId));
      if (handoff5) handoff5.addEventListener('click', () => handoffTo('model5', __activeCardId));
      const handoffAllBtn = document.getElementById('handoffAllBtn');
      if (handoffAllBtn) handoffAllBtn.addEventListener('click', () => handoffAllFrom(__activeCardId));

      // Clear functions
      function clearConversation(modelId) {
        console.log(`Frontend: clearConversation called for ${modelId}`, new Error().stack);
        const box = out[modelId];
        if (box) {
          box.textContent = '';
          box.dataset.empty = 'true';
        }
        if (!window.__histories) window.__histories = { model1: [], model2: [], model3: [] };
        if (window.__histories[modelId]) window.__histories[modelId] = [];
        const lat = document.getElementById('lat-' + modelId);
        if (lat) lat.textContent = '';
        const follow = document.getElementById('follow-' + modelId);
        if (follow) follow.value = '';
      }
      function clearAllConversations() {
        ['model1','model2','model3','model5'].forEach(clearConversation);
      }
      const resetAllBtn = document.getElementById('resetAllBtn');
      if (resetAllBtn) resetAllBtn.addEventListener('click', clearAllConversations);
      const resetLayoutBtn = document.getElementById('resetLayoutBtn');
      if (resetLayoutBtn) resetLayoutBtn.addEventListener('click', resetEqualLayout);
      
      // Close all research windows functionality
      function closeAllResearchWindows() {
        // Close all GPT Deep windows
        closeResearchWindows('gpt');
        // Close all Gemini windows  
        closeResearchWindows('gemini');
      }
      const closeAllWindowsBtn = document.getElementById('closeAllWindowsBtn');
      if (closeAllWindowsBtn) closeAllWindowsBtn.addEventListener('click', closeAllResearchWindows);
      const clear1 = document.getElementById('clear-model1');
      const clear2 = document.getElementById('clear-model2');
      const clear3 = document.getElementById('clear-model3');
      const clear5 = document.getElementById('clear-model5');
      if (clear1) clear1.addEventListener('click', () => clearConversation('model1'));
      if (clear2) clear2.addEventListener('click', () => clearConversation('model2'));
      if (clear3) clear3.addEventListener('click', () => clearConversation('model3'));
      if (clear5) clear5.addEventListener('click', () => clearConversation('model5'));

      // Search toggle functionality
      let searchModeActive = false;
      const searchToggleBtn = document.getElementById('searchToggleBtn');
      if (searchToggleBtn) {
        searchToggleBtn.addEventListener('click', () => {
          searchModeActive = !searchModeActive;
          // Disable deep research if search is activated
          if (searchModeActive && deepResearchModeActive) {
            deepResearchModeActive = false;
            if (deepResearchToggleBtn) {
              deepResearchToggleBtn.style.backgroundColor = '';
              deepResearchToggleBtn.style.color = '';
            }
          }
          searchToggleBtn.style.backgroundColor = searchModeActive ? '#007aff' : '';
          searchToggleBtn.style.color = searchModeActive ? 'white' : '';
          searchToggleBtn.title = searchModeActive ? 'Search mode active - click to disable' : 'Toggle search mode - when active, all questions use search model';
        });
      }

      // Deep Research toggle functionality
      let deepResearchModeActive = false;
      const deepResearchToggleBtn = document.getElementById('deepResearchToggleBtn');
      if (deepResearchToggleBtn) {
        deepResearchToggleBtn.addEventListener('click', () => {
          // If there are windows open, close them instead of toggling mode
          if (researchWindows.gpt.size > 0) {
            closeResearchWindows('gpt');
            return;
          }
          
          // Just open a new GPT Deep window - no need to disable other modes
          const label = el('model-6').options[el('model-6').selectedIndex]?.text || 'GPT Deep';
          openResearchCard('openai', el('model-6').value, label);
        });
      }



      // Gemini Research toggle functionality
      let geminiResearchModeActive = false;
      const geminiResearchToggleBtn = document.getElementById('geminiResearchToggleBtn');
      if (geminiResearchToggleBtn) {
        geminiResearchToggleBtn.addEventListener('click', () => {
          // If there are windows open, close them instead of toggling mode
          if (researchWindows.gemini.size > 0) {
            closeResearchWindows('gemini');
            return;
          }
          
          // Just open a new Gemini Deep window - no need to disable other modes
          const label = el('model-8').options[el('model-8').selectedIndex]?.text || 'Gemini';
          openResearchCard('gemini', el('model-8').value, label);
        });
      }

      // Super Research toggle functionality
      let superResearchModeActive = false;
      const superResearchToggleBtn = document.getElementById('superResearchToggleBtn');
      if (superResearchToggleBtn) {
        superResearchToggleBtn.addEventListener('click', () => {
          superResearchModeActive = !superResearchModeActive;
          // Disable other modes if Super research is activated
          if (superResearchModeActive) {
            if (searchModeActive) {
              searchModeActive = false;
              if (searchToggleBtn) { searchToggleBtn.style.backgroundColor = ''; searchToggleBtn.style.color = ''; }
            }
            if (deepResearchModeActive) {
              deepResearchModeActive = false;
              if (deepResearchToggleBtn) { deepResearchToggleBtn.style.backgroundColor = ''; deepResearchToggleBtn.style.color = ''; }
            }

            if (geminiResearchModeActive) {
              geminiResearchModeActive = false;
              if (geminiResearchToggleBtn) { geminiResearchToggleBtn.style.backgroundColor = ''; geminiResearchToggleBtn.style.color = ''; }
            }
          }
          superResearchToggleBtn.style.backgroundColor = superResearchModeActive ? 'linear-gradient(45deg, #ff6b35, #6366f1, #34a853)' : '';
          superResearchToggleBtn.style.background = superResearchModeActive ? 'linear-gradient(45deg, #ff6b35, #6366f1, #34a853)' : '';
          superResearchToggleBtn.style.color = superResearchModeActive ? 'white' : '';
          superResearchToggleBtn.title = superResearchModeActive ? 'Super Research mode active - uses all 3 research models then summarizes' : 'Super Research - uses all 3 research models then GPT-4o summarizes into one comprehensive report';
        });
      }

      // Wire card control buttons
      // Traffic light style controls
      document.getElementById('dot-hide-model1').addEventListener('click', () => hideModel('model1'));
      document.getElementById('dot-hide-model2').addEventListener('click', () => hideModel('model2'));
      document.getElementById('dot-hide-model3').addEventListener('click', () => hideModel('model3'));
      document.getElementById('dot-hide-model5').addEventListener('click', () => hideModel('model5'));
      document.getElementById('dot-max-model1').addEventListener('click', () => maximizeModel('model1'));
      document.getElementById('dot-max-model2').addEventListener('click', () => maximizeModel('model2'));
      document.getElementById('dot-max-model3').addEventListener('click', () => maximizeModel('model3'));
      document.getElementById('dot-max-model5').addEventListener('click', () => maximizeModel('model5'));
      // restoreAll now handled conditionally above; remove duplicate bindings


      // Super Research function - uses all 3 research models then summarizes
      async function askSuperResearch() {
        const promptText = el('prompt').value;
        if (!promptText.trim()) return;

        askBtn.disabled = true;
        const enabledModels = ['model1', 'model2', 'model3'].filter(m => el(`enable-${m}`).checked);
        if (enabledModels.length === 0) {
          enabledModels.push('model1'); // Default to model1 if none enabled
        }

        try {
          // Step 1: Run all research models
          const deepModel = el('model-6').value;
          const geminiModel = el('model-8').value;
          const summarizerModel = el('model-9').value;

          const researchPrompt = `Conduct comprehensive research on: ${promptText}

Please provide detailed analysis, findings, and insights.`;

          // Run research models in parallel
          const researchJobs = [
            { modelValue: deepModel, name: 'Deep Research' },
            { modelValue: geminiModel, name: 'Gemini' }
          ].map(async ({ modelValue, name }) => {
            const provider = getProviderFromModel(modelValue);
            if (!provider) return { name, result: `${name} model not available` };

            try {
              const res = await fetch('/api/ask', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                  prompt: researchPrompt,
                  model: modelValue,
                  provider: provider,
                  showReasoning: false,
                  advanced: {}
                })
              });
              const data = await res.json();
              return { name, result: data.answer || `${name} failed to respond` };
            } catch (error) {
              return { name, result: `${name} error: ${error.message}` };
            }
          });

          // Wait for all research to complete
          const researchResults = await Promise.all(researchJobs);

          // Step 2: Summarize all results with GPT-4o
          const summaryPrompt = `You are tasked with creating a comprehensive research summary. Below are research results from 3 different AI research systems on the topic: "${promptText}"

${researchResults.map(r => `## ${r.name} Results:\n${r.result}`).join('\n\n')}

Please create a unified, comprehensive report that:
1. Synthesizes the key findings from all three research sources
2. Identifies common themes and contradictions
3. Provides a balanced, well-structured final analysis
4. Highlights the most important insights and actionable information

Format your response as a detailed research report.`;

          const summarizerProvider = getProviderFromModel(summarizerModel);
          const summaryRes = await fetch('/api/ask', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              prompt: summaryPrompt,
              model: summarizerModel,
              provider: summarizerProvider,
              showReasoning: false,
              advanced: {}
            })
          });

          const summaryData = await summaryRes.json();
          const finalReport = summaryData.answer || 'Failed to generate summary';

          // Display results in the enabled models
          enabledModels.forEach(modelId => {
            const outEl = out[modelId];
            if (outEl) {
              outEl.innerHTML += `<div class="qa-pair">
                <div class="human-msg">${promptText}</div>
                <div class="ai-msg">
                  <div style="background: linear-gradient(45deg, #ff6b35, #6366f1, #34a853); padding: 8px; border-radius: 6px; margin-bottom: 12px; color: white; font-weight: bold;">
                    üöÄ Super Research Report
                  </div>
                  ${finalReport}
                  
                  <details style="margin-top: 16px; border: 1px solid #ddd; border-radius: 6px; padding: 8px;">
                    <summary style="cursor: pointer; font-weight: bold;">View Individual Research Results</summary>
                    ${researchResults.map(r => `<div style="margin: 12px 0; padding: 8px; background: #f5f5f5; border-radius: 4px;">
                      <strong>${r.name}:</strong><br>${r.result}
                    </div>`).join('')}
                  </details>
                </div>
              </div>`;
              outEl.scrollTop = outEl.scrollHeight;
              outEl.dataset.empty = 'false';
            }
          });

          // Update histories
          enabledModels.forEach(modelId => {
            if (!window.__histories[modelId]) window.__histories[modelId] = [];
            window.__histories[modelId].push({
              role: 'user',
              content: promptText
            }, {
              role: 'assistant', 
              content: finalReport
            });
          });

          // Clear prompt
          el('prompt').value = '';

        } catch (error) {
          console.error('Super Research error:', error);
          alert('Super Research failed: ' + error.message);
        } finally {
          askBtn.disabled = false;
        }
      }

      // API Usage Monitor ‚Äì opens a popup showing recent backend API usage log
      (function wireUsageMonitor(){
        const btn = document.getElementById('usageMonitorBtn');
        if (!btn) return;
        btn.addEventListener('click', async () => {
          const w = window.open('', 'api-usage-monitor', 'width=720,height=560');
          if (!w) return;
          w.document.write('<html><head><title>API Usage Monitor</title>'+
            '<style>body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;background:#0b1020;color:#eaeef7;margin:0;padding:12px;}'+
            'h2{margin:0 0 12px 0;font-weight:600;} table{width:100%;border-collapse:collapse;} th,td{font-size:12px;border-bottom:1px solid rgba(255,255,255,0.1);padding:6px;text-align:left;white-space:nowrap;} td.wrap{white-space:normal;word-break:break-word;}'+
            'thead{position:sticky;top:0;background:#0b1020;} .muted{opacity:0.75}</style></head><body><h2>API Usage</h2><div id="content">Loading‚Ä¶</div></body></html>');
          async function refresh(){
            try {
              const res = await fetch('/api/usage');
              const data = await res.json();
              const rows = (data.entries||[]).map(e=>{
                const when = new Date(e.ts||Date.now()).toLocaleTimeString();
                const payloadStr = e.payload ? encodeURIComponent(JSON.stringify(e.payload, null, 2)) : '';
                return `<tr><td>${when}</td><td>${e.provider||''}</td><td>${e.endpoint||''}</td><td>${e.model||''}</td><td>${e.ok===false?'<span class=\"muted\">fail</span>':'ok'}</td><td class=\"wrap\"><button data-payload=\"${payloadStr}\" style=\"font-size:11px;padding:4px 6px;\">View payload</button></td></tr>`;
              }).join('');
              w.document.getElementById('content').innerHTML = `<table><thead><tr><th>Time</th><th>Provider</th><th>Endpoint</th><th>Model</th><th>Status</th><th>Payload</th></tr></thead><tbody>${rows||''}</tbody></table>`;
              const buttons = w.document.querySelectorAll('button[data-payload]');
              buttons.forEach(btn=>{
                btn.addEventListener('click',()=>{
                  const raw = decodeURIComponent(btn.getAttribute('data-payload')||'');
                  const win = w.open('', '_blank', 'width=780,height=640');
                  if (!win) return;
                  win.document.write('<pre style="white-space:pre-wrap;word-wrap:break-word;padding:12px;background:#0b1020;color:#eaeef7;margin:0;">'+(raw?raw:'(no payload)')+'</pre>');
                });
              });
            } catch(err) {
              w.document.getElementById('content').textContent = 'Failed to load usage: '+(err?.message||err);
            }
          }
          refresh();
          w.__usageInterval = w.setInterval(refresh, 3000);
          w.addEventListener('beforeunload', ()=> { if (w.__usageInterval) clearInterval(w.__usageInterval); });
        });
      })();

      // Add Window button wiring
      (function wireAddWindow(){
        const btn = document.getElementById('addWindowBtn');
        if (!btn) return;
        btn.addEventListener('click', () => {
          const fallback = document.getElementById('model-2')?.value || document.getElementById('model-1')?.value || 'gpt-5-mini-2025-08-07';
          openGeneralCard(fallback);
        });
      })();

      // Helper: position a newly created card without resetting entire layout
      function positionNewCard(cardId) {
        const card = document.getElementById(cardId);
        const answers = document.getElementById('answers');
        if (!card || !answers) return;
        // If already isolated, keep; else initialize once
        if (!answers.classList.contains('isolated')) {
          initializeAllCardsForIsolation();
        }
        const containerRect = answers.getBoundingClientRect();
        const cards = Array.from(answers.querySelectorAll('.card')).filter(c => c.id !== cardId);
        let maxBottom = 0;
        cards.forEach(c => {
          const top = parseFloat(c.style.top) || (c.getBoundingClientRect().top - containerRect.top);
          const h = parseFloat(c.style.height) || c.getBoundingClientRect().height;
          const bottom = top + h;
          if (bottom > maxBottom) maxBottom = bottom;
        });
        const width = Math.min(560, Math.max(420, Math.round(containerRect.width * 0.5)));
        const left = 12;
        const top = Math.max(0, Math.round(maxBottom + 12));
        card.style.position = 'absolute';
        card.style.left = left + 'px';
        card.style.top = top + 'px';
        card.style.width = width + 'px';
        // don't force a fixed height if CSS already sets; only set if unset
        if (!card.style.height) card.style.height = '420px';
        const spec = getCurrentCardSpec(cardId);
        if (spec) saveLayoutForCard(cardId, spec);
        updateIsolatedLayout();
      }

      // Summarize outputs from visible windows into bullet points
      (function wireSummarize(){
        const btn = document.getElementById('summarizeBtn');
        if (!btn) return;
        btn.addEventListener('click', async () => {
          const answers = document.getElementById('answers');
          const visibleCards = Array.from(answers.querySelectorAll('.card')).filter(c => getComputedStyle(c).display !== 'none');
          const items = [];
          visibleCards.forEach(card => {
            const id = card.id.replace(/^card-/, '');
            const box = out[id];
            if (!box) return;
            const msgs = box.querySelectorAll('.msg.assistant');
            if (!msgs || msgs.length === 0) return;
            const last = msgs[msgs.length - 1];
            const titleSpan = card.querySelector('.title span');
            const title = (titleSpan?.textContent || id).trim();
            const text = (last.textContent || '').trim();
            if (text) items.push({ id, title, text });
          });
          if (items.length === 0) { alert('No outputs to summarize yet.'); return; }

          // Choose summarizer model - default to gpt-4o-mini
          let summarizerModel = document.getElementById('model-9')?.value || 'gpt-4o-mini';
          if (!summarizerModel) {
            summarizerModel = 'gpt-4o-mini';
          }
          const providerKey = getProviderFromModel(summarizerModel);
          if (!providerKey) { alert('Please configure a summarizer model in settings.'); return; }

          const uid = openGeneralCard(summarizerModel, 'Summary');
          // Maximize the new summary window in the center
          try {
            const answersEl = document.getElementById('answers');
            if (answersEl) answersEl.classList.add('single');
            // Hide others visually by ensuring only the new card has .maximized
            const allCards = Array.from(document.querySelectorAll('.card'));
            const target = document.getElementById('card-' + uid);
            allCards.forEach(c => c.classList.remove('maximized'));
            if (target) {
              // Clear inline geometry to let .maximized sizing take effect
              target.style.position = '';
              target.style.left = '';
              target.style.top = '';
              target.style.width = '';
              target.style.height = '';
              target.style.zIndex = '';
              target.classList.add('maximized');
              // Scroll into view center
              target.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
            document.getElementById('brand')?.classList.add('hidden');
            document.body.classList.add('max-on');
          } catch {}
          setLoading(uid, true);

          // Load prompt config from backend so it can be edited in src/prompts.js
          let systemText = 'You are a helpful summarizer. Return only a bullet list.';
          let preface = [
            'Summarize the following model outputs into a concise list of bullet points.',
            '- Use short, scannable bullets.',
            '- Group related ideas and remove duplicates.',
            '- Highlight agreements, contradictions, and standout insights.',
            '- Aim for 5‚Äì12 bullets.',
          ];
          let sourcesTitle = 'Sources:';
          try {
            console.log('Fetching summarize config...');
            const cfgRes = await fetch('/api/prompts/summarize');
            const cfgData = await cfgRes.json();
            console.log('Summarize config response:', cfgData);
            if (cfgData?.ok && cfgData.config) {
              console.log('Using config:', cfgData.config);
              systemText = cfgData.config.system || systemText;
              if (Array.isArray(cfgData.config.preface)) preface = cfgData.config.preface;
              if (cfgData.config.sourcesTitle) sourcesTitle = cfgData.config.sourcesTitle;
              console.log('Final systemText:', systemText);
              console.log('Final preface:', preface);
            } else {
              console.log('Config not loaded, using defaults');
            }
          } catch (err) {
            console.error('Failed to load summarize config:', err);
          }
          // Only include sources in the user prompt - instructions go in system prompt
          const promptParts = [];
          promptParts.push(sourcesTitle);
          items.forEach((it, idx) => { promptParts.push(`\n[${idx+1}] ${it.title}:\n${it.text}`); });
          const promptText = promptParts.join('\n');

          try {
            const requestBody = {
              prompt: promptText,
              system: systemText,
              histories: window.__histories,
              modelId: uid,
              providers: { [providerKey]: true },
              models: { [providerKey]: summarizerModel },
              temperature: 0.2,
              maxTokens: 800,
              timeoutMs: 30000,
              showReasoning: false
            };
            console.log('Summarizer request:', requestBody);
            const res = await fetch('/api/ask', {
              method: 'POST', headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(requestBody)
            });
            const data = await res.json();
            const r = data[providerKey];
            const box = out[uid];
            if (box) {
              const u = document.createElement('div'); u.className = 'msg user'; u.textContent = `Summarize ${items.length} outputs into bullet points.`; box.appendChild(u);
              const a = document.createElement('div'); a.className = 'msg assistant'; a.textContent = r?.ok ? (r.text || '') : (r?.error || 'Error'); box.appendChild(a);
              box.dataset.empty = 'false'; box.scrollTop = box.scrollHeight;
              const hist = window.__histories[uid] || (window.__histories[uid] = []);
              hist.push({ role: 'user', content: promptText }, { role: 'assistant', content: a.textContent });
            }
          } catch (err) {
            const box = out[uid];
            if (box) {
              const a = document.createElement('div'); a.className = 'msg assistant'; a.textContent = 'Error: ' + (err?.message || err); box.appendChild(a); box.scrollTop = box.scrollHeight; box.dataset.empty = 'false';
            }
          } finally {
            setLoading(uid, false);
          }
        });
      })();
    </script>
  </body>
  </html>


