<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Multi Answers</title>
    <style>
      :root {
        --bg-1: #f7f9fc;
        --bg-2: #eef3f9;
        --tint-1: #e9eef7;
        --tint-2: #f6f0ff;
        --text: #0b1220;
        --muted: #5b6577;
        --brand: #0a84ff; /* Apple blue */
        --danger: #d70015;
        --border: rgba(0,0,0,0.08);
        --card: rgba(255,255,255,0.7);
      }
      * { box-sizing: border-box; }
      body {
        font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
        margin: 0;
        color: var(--text);
        background-image: url('michael-fousert-lE5-z4nTCTQ-unsplash.jpg');
        background-position: center center;
        background-repeat: no-repeat;
        background-attachment: fixed;
        background-size: cover; /* Fill page without distortion (may crop) */
        padding-top: 76px; /* prevent overlap with fixed brand */
      }
      body.video-on { background-image: none; }
      body.max-on { padding-top: 0; }
      /* Dark mode theme overrides */
      body.dark {
        --text: #eef3fb;
        --muted: #b7c3d6;
        --border: rgba(255,255,255,0.16);
        --card: rgba(28,34,44,0.55); /* lighter than before */
      }
      /* Header removed per request */
      .container { max-width: 95%; margin: 0 auto; padding: 12px 16px; }
      h2 { margin: 0; font-weight: 700; letter-spacing: 0.2px; }
      p.small { color: var(--muted); margin-top: 6px; }
      .grid-3, .row { display: grid; grid-template-columns: 1fr 2fr 1fr; gap: 16px; align-items: start; }
      /* Ensure the answers row specifically uses wider center column */
      .answers.row { grid-template-columns: 1fr 2fr 1fr; }
      .panel {
        position: relative;
        background: var(--card);
        border: 1px solid var(--border);
        border-radius: 16px;
        padding: 16px;
        backdrop-filter: blur(14px);
        box-shadow: 0 10px 30px rgba(0,0,0,0.06), inset 0 1px 0 rgba(255,255,255,0.5);
      }
      label { display: block; font-size: 12px; color: var(--muted); margin-bottom: 6px; }
      input[type="text"], textarea, select, input[type="number"] {
        width: 100%; padding: 10px 12px; border-radius: 12px;
        border: 1px solid var(--border); background: rgba(255,255,255,0.8);
        color: var(--text); outline: none; box-shadow: inset 0 1px 0 rgba(255,255,255,0.6);
        font-size: 16px; font-family: inherit;
      }
      textarea { min-height: 90px; }
      .toolbar { display: flex; flex-wrap: wrap; gap: 10px; align-items: center; }
      .btn { 
        padding: 10px 14px; border: 1px solid rgba(10,132,255,0.25);
        border-radius: 12px; background: linear-gradient(180deg, rgba(10,132,255,0.25), rgba(10,132,255,0.18));
        color: #0b1220; font-weight: 600; cursor: pointer;
        box-shadow: 0 6px 22px rgba(10,132,255,0.12), inset 0 1px 0 rgba(255,255,255,0.6);
      }
      .btn-wide { min-width: 260px; }
      /* Same vertical rhythm as .btn, just shorter width and smaller font */
      .btn-sm { padding: 10px 12px; font-size: 12px; display: inline-flex; align-items: center; }
      .btn:disabled { opacity: 0.6; cursor: not-allowed; }
      .switch { display: inline-flex; align-items: center; gap: 6px; font-size: 13px; color: var(--muted); }
      .pill { display: inline-flex; align-items: center; gap: 6px; padding: 4px 8px; border-radius: 999px; border: 1px solid var(--border); background: rgba(255,255,255,0.7); color: var(--muted); font-size: 12px; }
      .answers { margin-top: 4px; position: relative; }
      .card {
        position: relative; background: var(--card);
        border: 1px solid var(--border); border-radius: 12px; padding: 10px;
        min-height: 200px; white-space: pre-wrap; backdrop-filter: blur(12px);
        box-shadow: 0 8px 18px rgba(0,0,0,0.06), inset 0 1px 0 rgba(255,255,255,0.5);
        resize: none; overflow: auto; min-width: 240px; min-height: 200px;
      }
      /* Subtle per-card tint; center uses a randomized base hue set in JS */
      .card { --tint-h: 210; --tint-s: 65%; --tint-l: 96%; --tint-a: 0.65; }
      .card { background: radial-gradient(circle at 50% 38%, hsla(var(--tint-h), var(--tint-s), var(--tint-l), var(--tint-a)), rgba(255,255,255,0.55) 68%); }
      body.dark .card { background: radial-gradient(circle at 50% 38%, hsla(var(--tint-h), 65%, 34%, 0.32), rgba(20,24,30,0.60) 68%); border-color: rgba(255,255,255,0.14); }
      /* Smooth brand-style panel animation (like top-left title) */
      .card { overflow: hidden; }
      .card::before {
        content: '';
        position: absolute; inset: -2px;
        border-radius: inherit; pointer-events: none;
        opacity: 0; transition: opacity 600ms ease;
        background: linear-gradient(90deg,
          hsl(210, 90%, 60%),
          hsl(280, 90%, 62%),
          hsl(340, 90%, 62%),
          hsl(210, 90%, 60%)
        );
        background-size: 400% 100%;
        mix-blend-mode: screen;
      }
      /* Subtle internal tint */
      .card::before {
        content: '';
        position: absolute; inset: 0;
        border-radius: inherit; pointer-events: none;
        background: hsla(var(--tint-h,210), 96%, 60%, 0.06);
        mix-blend-mode: screen;
        opacity: 0; transition: opacity 300ms ease;
      }
      /* Border glow active only during loading */
      .card::after {
        content: '';
        position: absolute; inset: 0;
        border-radius: inherit; pointer-events: none;
        box-shadow:
          0 0 0 2px hsla(var(--tint-h,210), 96%, 60%, 0.55) inset,
          0 0 24px hsla(var(--tint-h,210), 96%, 60%, 0.32) inset;
        opacity: 0; transition: opacity 300ms ease;
      }
      .card.loading { animation: none; }
      .card.loading::before { opacity: 0.28; animation: brandFlow 30s ease-in-out infinite; }
      body.dark .card.loading::before { opacity: 0.22; }
      .card.loading::after { opacity: 0.8; }
      .card.loading::after { animation: hueSpin 90s linear infinite; }
      .card.loading::before { animation: hueSpin 90s linear infinite; }
      @keyframes hueSpin {
        0%   { filter: hue-rotate(0deg); }
        100% { filter: hue-rotate(360deg); }
      }
      .card.tinted::before { opacity: 1; }
      /* brandFlow keyframes already defined for the brand title; reused here */
      /* Custom resize handles on all edges and corners */
      .resize-handle { position: absolute; background: transparent; border: none; z-index: 10; }
      .resize-handle:hover { background: transparent; }
      .resize-n  { top: -4px; left: 10px; right: 10px; height: 8px; cursor: n-resize; }
      .resize-s  { bottom: -4px; left: 10px; right: 10px; height: 8px; cursor: s-resize; }
      .resize-w  { left: -4px; top: 10px; bottom: 10px; width: 8px; cursor: w-resize; }
      .resize-e  { right: -4px; top: 10px; bottom: 10px; width: 8px; cursor: e-resize; }
      .resize-nw { top: -4px; left: -4px; width: 12px; height: 12px; cursor: nw-resize; border-radius: 6px; }
      .resize-ne { top: -4px; right: -4px; width: 12px; height: 12px; cursor: ne-resize; border-radius: 6px; }
      .resize-sw { bottom: -4px; left: -4px; width: 12px; height: 12px; cursor: sw-resize; border-radius: 6px; }
      .resize-se { bottom: -4px; right: -4px; width: 12px; height: 12px; cursor: se-resize; border-radius: 6px; }
      /* Individual card resizing only - no column resizers */
      .card h3 { position: relative; display: flex; align-items: center; justify-content: space-between; margin: 0 0 6px 0; font-size: 14px; font-weight: 500; }
      .card h3 { cursor: move; user-select: none; }
      .mini { margin-top: 4px; display: flex; gap: 8px; align-items: center; }
      .mini input[type="text"] { flex: 1; padding: 8px 10px; border-radius: 10px; border: 1px solid var(--border); background: rgba(255,255,255,0.8); font-size: 15px; }
      .mini .mini-btn { padding: 8px 12px; border: 1px solid rgba(10,132,255,0.25); border-radius: 10px; background: linear-gradient(180deg, rgba(10,132,255,0.2), rgba(10,132,255,0.12)); font-weight: 600; cursor: pointer; }
      .controls { display: inline-flex; gap: 6px; align-items: center; margin-left: 8px; }
      .icon-btn { padding: 4px 8px; border: 1px solid var(--border); border-radius: 8px; background: rgba(255,255,255,0.7); cursor: pointer; font-size: 12px; }
      
      /* Hover lighting effect for interactive buttons */
      button, .btn, .mini-btn, .icon-btn {
        transition: box-shadow 0.35s ease, filter 0.35s ease;
      }
      button:hover, .btn:hover, .mini-btn:hover, .icon-btn:hover {
        box-shadow: 0 0 0px rgba(10,132,255,0.0), 0 0 0px rgba(10,132,255,0.0);
        animation: glowUp 0.35s forwards;
      }
      button:active, .btn:active, .mini-btn:active, .icon-btn:active {
        box-shadow: 0 0 16px rgba(10,132,255,0.8), 0 0 8px rgba(10,132,255,0.9);
        filter: brightness(1.28);
      }
      @keyframes glowUp {
        0% { box-shadow: 0 0 0px rgba(10,132,255,0.0), 0 0 0px rgba(10,132,255,0.0); filter: brightness(1); }
        100% { box-shadow: 0 0 12px rgba(10,132,255,0.45), 0 0 4px rgba(10,132,255,0.65); filter: brightness(1.12); }
      }
      .dot {
        transition: box-shadow 0.3s ease, transform 0.3s ease;
      }
      .dot {
        transition: box-shadow 0.35s ease, transform 0.35s ease;
      }
      .dot:hover {
        animation: dotGlow 0.35s forwards;
      }
      .dot:active {
        box-shadow: 0 0 12px rgba(255,255,255,1);
        transform: scale(1.35);
      }
      @keyframes dotGlow {
        0% { box-shadow: 0 0 0px rgba(255,255,255,0); transform: scale(1); }
        100% { box-shadow: 0 0 8px rgba(255,255,255,0.8); transform: scale(1.25); }
      }
      .card h3 .title {
        display: flex;
        align-items: center;
        gap: 8px;
        position: absolute;
        right: 8px;
        left: auto;
        transform: none;
        pointer-events: none;
        max-width: calc(100% - 160px); /* leave room for traffic dots */
        white-space: normal;           /* allow wrapping */
        word-break: break-word;
        text-align: right;
        line-height: 1.2;
      }
      .card h3 .title span { position: relative; font-weight: 500; letter-spacing: 0.2px; }
      /* Remove previous shiny loading effects */
      .card.loading .title span, .card.loading .title span::before, .card.loading .title span::after { animation: none; background: none; color: inherit; filter: none; }
      /* Removed shine/sparkle progress-like effects; only emoji sparks remain */
      /* Emoji sparks that pop around model names while loading */
      .spark {
        position: absolute;
        top: 50%; left: 50%;
        transform: translate(-50%, -50%);
        pointer-events: none;
        user-select: none;
        filter: drop-shadow(0 1px 1px rgba(0,0,0,0.25));
        animation: pop-float var(--d, 1.2s) ease-out forwards;
        will-change: transform, opacity;
      }
      @keyframes pop-float {
        0% { opacity: 0; transform: translate(calc(-50% + var(--x, 0px)), calc(-50% + 6px)) scale(0.6) rotate(0deg); }
        12% { opacity: 1; transform: translate(calc(-50% + var(--x, 0px)), calc(-50% - 6px)) scale(1) rotate(var(--rot, 12deg)); }
        100% { opacity: 0; transform: translate(calc(-50% + var(--x, 0px)), calc(-50% - 70px)) scale(0.95) rotate(var(--rot, 12deg)); }
      }
      .traffic { display: inline-flex; gap: 6px; align-items: center; margin-right: 8px; }
      .dot { width: 12px; height: 12px; border-radius: 50%; cursor: pointer; border: 1px solid rgba(0,0,0,0.15); box-shadow: inset 0 1px 0 rgba(255,255,255,0.6); }
      .dot.red { background: #ff5f56; }
      .dot.yellow { background: #ffbd2e; }
      .dot.green { background: #27c93f; }
      /* Additional beautiful dots for height controls */
      .dot.blue { background: #0a84ff; }
      .dot.purple { background: #af52de; }
      .card.maximized { position: static; width: 100%; height: auto; z-index: auto; padding: 16px; border-radius: 16px; min-height: calc(100vh - 200px); margin: 0; }
      .card.maximized .convo { max-height: none; min-height: 60vh; padding: 12px; overflow-y: visible; }
      .card.maximized .msg { font-size: 1.08rem; line-height: 1.6; padding: 12px 14px; }
      .card.maximized h3 { margin-bottom: 10px; font-size: 18px; }
      .card.maximized .mini { margin-top: 14px; }
      .card.maximized .mini input[type="text"] { padding: 10px 12px; font-size: 1.02rem; }
      .card.maximized .mini .mini-btn { padding: 10px 16px; font-size: 1.02rem; }
      .answers.single { display: block; }
      .answers.single .card { display: none; }
      .answers.single .card.maximized { display: block; width: 100%; max-width: none; }
      /* Isolated layout: each card positioned independently */
      .answers.isolated { position: relative; display: block; min-height: 500px; }
      .answers.isolated .card { position: absolute; }
      .convo { position: relative; max-height: 380px; overflow-y: auto; display: flex; flex-direction: column; gap: 6px; border-radius: 8px; padding: 4px; background: rgba(255,255,255,0.55); border: 1px solid var(--border); }
      .convo[data-empty="true"] { border-color: transparent; background: transparent; }
      .msg { padding: 8px 10px; border-radius: 10px; border: 1px solid var(--border); background: rgba(255,255,255,0.8); }
      .msg.user { background: rgba(10,132,255,0.08); border-color: rgba(10,132,255,0.2); }
      .msg.assistant { background: rgba(0,0,0,0.03); }
      .latency { display:none; }
      .error { color: var(--danger); white-space: pre-wrap; }
      footer { color: var(--muted); font-size: 12px; margin-top: 16px; }
      @media (max-width: 900px) { .row, .grid-3 { grid-template-columns: 1fr; } }

       /* Details (Advanced) styling */
       details { border: 1px solid var(--border); border-radius: 12px; padding: 8px 12px; background: rgba(255,255,255,0.6); backdrop-filter: blur(8px); }
       /* Hide the advanced panel until toggled open via the button */
       #advanced { display: none; }
       #advanced[open] { display: block; }
       /* Hide native summary; we use a toolbar button to toggle */
       summary { display: none; }
       summary::-webkit-details-marker { display: none; }
       details[open] { border-color: rgba(10,132,255,0.25); }
      .brand-fixed {
        position: fixed;
        top: 12px;
        left: 16px;
        z-index: 1000;
        font-weight: 800;
        font-size: 1.5em;
        letter-spacing: 0.4px;
        color: #0b1220;
        background: rgba(255,255,255,0.6);
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        border: 1px solid var(--border);
        padding: 8px 12px;
        border-radius: 12px;
        box-shadow: 0 8px 20px rgba(0,0,0,0.08);
        text-shadow: 0 1px 1px rgba(255,255,255,0.5), 0 1px 2px rgba(0,0,0,0.06);
        user-select: none;
        pointer-events: none;
      }
      .brand-fixed.hidden { opacity: 0; }
      body.dark .brand-fixed { color: #eef4ff; background: rgba(24,28,36,0.48); border-color: rgba(255,255,255,0.14); }

      /* Animated gradient text for brand */
      .brand-text {
        background: linear-gradient(90deg,
          hsl(210, 90%, 55%),
          hsl(280, 90%, 60%),
          hsl(340, 90%, 60%),
          hsl(210, 90%, 55%)
        );
        background-size: 400% 100%;
        -webkit-background-clip: text; background-clip: text;
        color: transparent;
        animation: brandFlow 30s ease-in-out infinite;
        will-change: background-position;
        display: inline-block;
      }
      @keyframes brandFlow {
        0%   { background-position: 0% 50%; }
        50%  { background-position: 100% 50%; }
        100% { background-position: 0% 50%; }
      }
      @media (prefers-reduced-motion: reduce) {
        .brand-text { animation-duration: 60s; }
      }

      /* Fullscreen background video */
      .bg-video { position: fixed; inset: 0; width: 100%; height: 100%; object-fit: cover; z-index: -1; display: none; filter: saturate(1.05) brightness(0.95); }
      body.video-on .bg-video { display: block; }

      /* Dark mode buttons */
      body.dark .btn,
      body.dark .mini-btn,
      body.dark .icon-btn {
        color: #eef3fb;
        border-color: rgba(10,132,255,0.45);
        background: linear-gradient(180deg, rgba(10,132,255,0.32), rgba(10,132,255,0.22));
      }

      /* Dark mode inputs */
      body.dark input[type="text"],
      body.dark textarea,
      body.dark select,
      body.dark input[type="number"] {
        background: rgba(24,26,32,0.92);
        color: #eef3fb;
        border-color: rgba(255,255,255,0.12);
      }

      body.dark select option { color: #0b1220; }

      /* Dark mode conversation backgrounds */
      body.dark .convo { background: rgba(30,34,42,0.72); border-color: rgba(255,255,255,0.10); }
      body.dark .convo[data-empty="true"] { background: transparent; border-color: transparent; }

      body.dark .msg { background: rgba(48,52,60,0.80); border-color: rgba(255,255,255,0.14); }
      body.dark .msg.user { background: rgba(10,132,255,0.18); border-color: rgba(10,132,255,0.35); }
    </style>
  </head>
  <body>
    <video class="bg-video" id="bgVideo" autoplay loop muted playsinline preload="auto" poster="michael-fousert-lE5-z4nTCTQ-unsplash.jpg">
      <source src="bg.webm" type="video/webm" />
      <source src="bg.mp4" type="video/mp4" />
    </video>
    <div class="brand-fixed" id="brand"><span class="brand-text">🤔 Many Answers</span></div>
    <div class="container">
      <div class="panel" id="panel-top" style="display:grid; gap:12px;">
        <div>
          <label>Prompt</label>
          <textarea id="prompt" placeholder="Ask anything..."></textarea>
        </div>
        <div class="row">
          <div>
            <label>Model 1</label>
            <select id="model-1">
              <option value="o3-pro-2025-06-10">o3-pro 2025-06-10</option>
              <option value="o3-2025-04-16">o3 2025-04-16</option>
              <option value="o4-mini-2025-04-16">o4-mini 2025-04-16</option>
              <option value="gpt-5-mini-2025-08-07">GPT-5 Mini</option>
              <option value="gpt-4o">GPT-4o</option>
              <option value="gpt-4o-mini">GPT-4o Mini</option>
              <option value="gpt-4.1">GPT-4.1</option>
              <option value="gpt-4-turbo">GPT-4 Turbo</option>
              <option value="claude-opus-4-1-20250805" selected>Claude Opus 4.1 20250805</option>
              <option value="claude-4.1-opus">Claude Opus 4.1</option>
              <option value="claude-4-sonnet">Claude Sonnet 4</option>
              <option value="claude-3-5-sonnet-latest">Claude 3.5 Sonnet</option>
              <option value="claude-3-opus-latest">Claude 3 Opus</option>
              <option value="claude-3-haiku-latest">Claude 3 Haiku</option>
              <option value="gemini-2.5-pro">Gemini 2.5 Pro</option>
              <option value="gemini-2.5-flash">Gemini 2.5 Flash</option>
              <option value="gemini-1.5-pro">Gemini 1.5 Pro</option>
              <option value="gemini-1.5-flash">Gemini 1.5 Flash</option>
              <option value="gemini-1.5-flash-8b">Gemini 1.5 Flash 8B</option>
            </select>
          </div>
          <div>
            <label>Model 2</label>
            <select id="model-2">
              <option value="">-- Disabled --</option>
              <option value="claude-opus-4-1-20250805">Claude Opus 4.1 20250805</option>
              <option value="o3-pro-2025-06-10">o3-pro 2025-06-10</option>
              <option value="o3-2025-04-16">o3 2025-04-16</option>
              <option value="o4-mini-2025-04-16">o4-mini 2025-04-16</option>
              <option value="gpt-5-mini-2025-08-07" selected>GPT-5 Mini</option>
              <option value="gpt-4o">GPT-4o</option>
              <option value="gpt-4o-mini">GPT-4o Mini</option>
              <option value="gpt-4.1">GPT-4.1</option>
              <option value="gpt-4-turbo">GPT-4 Turbo</option>
              <option value="claude-opus-4-1-20250805">Claude Opus 4.1 20250805</option>
              <option value="claude-4.1-opus">Claude Opus 4.1</option>
              <option value="claude-4-sonnet">Claude Sonnet 4</option>
              <option value="claude-3-5-sonnet-latest">Claude 3.5 Sonnet</option>
              <option value="claude-3-opus-latest">Claude 3 Opus</option>
              <option value="claude-3-haiku-latest">Claude 3 Haiku</option>
              <option value="gemini-2.5-pro">Gemini 2.5 Pro</option>
              <option value="gemini-2.5-flash">Gemini 2.5 Flash</option>
              <option value="gemini-1.5-pro">Gemini 1.5 Pro</option>
              <option value="gemini-1.5-flash">Gemini 1.5 Flash</option>
              <option value="gemini-1.5-flash-8b">Gemini 1.5 Flash 8B</option>
            </select>
          </div>
          <div>
            <label>Model 3</label>
            <select id="model-3">
              <option value="">-- Disabled --</option>
              <option value="gemini-2.5-pro">Gemini 2.5 Pro</option>
              <option value="o3-pro-2025-06-10">o3-pro 2025-06-10</option>
              <option value="o3-2025-04-16" selected>o3 2025-04-16</option>
              <option value="o4-mini-2025-04-16">o4-mini 2025-04-16</option>
              <option value="gpt-5-mini-2025-08-07">GPT-5 Mini</option>
              <option value="gpt-4o">GPT-4o</option>
              <option value="gpt-4o-mini">GPT-4o Mini</option>
              <option value="gpt-4.1">GPT-4.1</option>
              <option value="gpt-4-turbo">GPT-4 Turbo</option>
              <option value="claude-opus-4-1-20250805">Claude Opus 4.1 20250805</option>
              <option value="claude-4.1-opus">Claude Opus 4.1</option>
              <option value="claude-4-sonnet">Claude Sonnet 4</option>
              <option value="claude-3-5-sonnet-latest">Claude 3.5 Sonnet</option>
              <option value="claude-3-opus-latest">Claude 3 Opus</option>
              <option value="claude-3-haiku-latest">Claude 3 Haiku</option>
              <option value="gemini-2.5-pro">Gemini 2.5 Pro</option>
              <option value="gemini-2.5-flash">Gemini 2.5 Flash</option>
              <option value="gemini-1.5-pro">Gemini 1.5 Pro</option>
              <option value="gemini-1.5-flash">Gemini 1.5 Flash</option>
              <option value="gemini-1.5-flash-8b">Gemini 1.5 Flash 8B</option>
            </select>
          </div>
        </div>
        <div class="toolbar" style="margin-top:6px; display:flex; gap:10px; align-items:center; flex-wrap: wrap;">
          <label class="switch"><input type="checkbox" id="toggle-video" /> Dynamic background</label>
          <label class="switch"><input type="checkbox" id="toggle-dark" /> Dark mode</label>
          <input type="file" id="bgUpload" accept="image/*" style="display:none" />
          <button id="bgUploadBtn" class="btn btn-sm">Upload background</button>
          <button id="bgClearBtn" class="btn btn-sm">Clear background</button>
        </div>
        <div class="toolbar">
          <button id="askBtn" class="btn btn-wide">Ask all</button>
          <button id="streamBtn" class="btn">Stream Model 1</button>
          <button id="drawBtn" class="btn">Draw Model 1</button>
          <button id="advBtn" class="btn btn-sm">Advanced</button>
          <button id="resetAllBtn" class="btn btn-sm" title="Clear all conversations">Start over</button>
          <button id="resetLayoutBtn" class="btn btn-sm" title="Reset card layout to grid">Reset layout</button>
          <label class="switch"><input type="checkbox" id="enable-model1" checked /> Model 1</label>
          <label class="switch"><input type="checkbox" id="enable-model2" checked /> Model 2</label>
          <label class="switch"><input type="checkbox" id="enable-model3" checked /> Model 3</label>
          <label class="switch"><input type="checkbox" id="show-reasoning" /> Show reasoning</label>

        </div>
        <details id="advanced">
          <div style="margin-top:10px; display:grid; gap:8px;">
            <label for="advancedJson">Advanced JSON per provider</label>
            <textarea id="advancedJson" style="min-height: 150px; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;">{
  "openai": {
    "system": "You are a helpful assistant. Be concise and direct.",
    "temperature": 0.2,
    "maxTokens": 1024,
    "timeoutMs": 30000
  },
  "claude": {
    "system": "You are a helpful assistant. Be concise and direct.",
    "temperature": 0.2,
    "maxTokens": 1024,
    "timeoutMs": 30000
  },
  "gemini": {
    "system": "You are a helpful assistant. Be concise and direct.",
    "temperature": 0.2,
    "maxTokens": 1024,
    "timeoutMs": 30000
  }
}</textarea>
            <small class="small" style="color: var(--muted);">Invalid JSON will be ignored. Keys are optional; unspecified ones keep their previous values.</small>
          </div>
        </details>
      </div>


      <div class="answers row" id="answers" style="margin-top:16px; position: relative;">
        <div class="card" id="card-model1">
          <h3>
            <span style="display:inline-flex; align-items:center; gap:8px;">
              <span class="traffic">
                <span class="dot red" id="dot-hide-model1" title="Hide"></span>
                <span class="dot yellow" id="dot-restore-model1" title="Restore"></span>
                <span class="dot green" id="dot-max-model1" title="Maximize"></span>
                <span class="dot blue" id="dot-tall-model1" title="Taller"></span>
                <span class="dot purple" id="dot-short-model1" title="Shorter"></span>
              </span>
              <div class="title"><span data-text="Model 1" id="model1-name">Model 1</span></div>
              <button class="icon-btn" id="clear-model1" title="Clear this conversation">Clear</button>
            </span>
            
          </h3>
          <div class="convo" id="model1" data-empty="true"></div>
          <div class="mini">
            <input id="follow-model1" type="text" placeholder="Follow up to Model 1…" />
            <button id="ask-model1" class="mini-btn">Ask Model 1</button>
          </div>
        </div>
        <div class="card" id="card-model2">
          <h3>
            <span style="display:inline-flex; align-items:center; gap:8px;">
              <span class="traffic">
                <span class="dot red" id="dot-hide-model2" title="Hide"></span>
                <span class="dot yellow" id="dot-restore-model2" title="Restore"></span>
                <span class="dot green" id="dot-max-model2" title="Maximize"></span>
                <span class="dot blue" id="dot-tall-model2" title="Taller"></span>
                <span class="dot purple" id="dot-short-model2" title="Shorter"></span>
              </span>
              <div class="title"><span data-text="Model 2" id="model2-name">Model 2</span></div>
              <button class="icon-btn" id="clear-model2" title="Clear this conversation">Clear</button>
            </span>
            
          </h3>
          <div class="convo" id="model2" data-empty="true"></div>
          <div class="mini">
            <input id="follow-model2" type="text" placeholder="Follow up to Model 2…" />
            <button id="ask-model2" class="mini-btn">Ask Model 2</button>
          </div>
        </div>
        <div class="card" id="card-model3">
          <h3>
            <span style="display:inline-flex; align-items:center; gap:8px;">
              <span class="traffic">
                <span class="dot red" id="dot-hide-model3" title="Hide"></span>
                <span class="dot yellow" id="dot-restore-model3" title="Restore"></span>
                <span class="dot green" id="dot-max-model3" title="Maximize"></span>
                <span class="dot blue" id="dot-tall-model3" title="Taller"></span>
                <span class="dot purple" id="dot-short-model3" title="Shorter"></span>
              </span>
              <div class="title"><span data-text="Model 3" id="model3-name">Model 3</span></div>
              <button class="icon-btn" id="clear-model3" title="Clear this conversation">Clear</button>
            </span>
            
          </h3>
          <div class="convo" id="model3" data-empty="true"></div>
          <div class="mini">
            <input id="follow-model3" type="text" placeholder="Follow up to Model 3…" />
            <button id="ask-model3" class="mini-btn">Ask Model 3</button>
          </div>
        </div>
      </div>
    </div>

    <script>
      const el = (id) => document.getElementById(id);
      const askBtn = el('askBtn');
      const streamBtn = el('streamBtn');
      const drawBtn = el('drawBtn');
      const statusEl = el('status');
      // in-memory conversation histories per model
      window.__histories = window.__histories || { model1: [], model2: [], model3: [] };
      const out = {
        model1: el('model1'),
        model2: el('model2'),
        model3: el('model3'),
      };
      
      // Helper function to get provider from model
      function getProviderFromModel(modelValue) {
        if (!modelValue) return null;
        if (modelValue.startsWith('gpt-') || modelValue.startsWith('o3-') || modelValue.startsWith('o4-') || modelValue.startsWith('dall-e')) return 'openai';
        if (modelValue.startsWith('claude-')) return 'claude';
        if (modelValue.startsWith('gemini-')) return 'gemini';
        return null;
      }
      
      // Update model display names when dropdowns change
      function updateModelNames() {
        for (let i = 1; i <= 3; i++) {
          const select = el(`model-${i}`);
          const nameEl = el(`model${i}-name`);
          if (select && nameEl) {
            const selectedText = select.options[select.selectedIndex]?.text || `Model ${i}`;
            nameEl.textContent = selectedText.includes('--') ? `Model ${i}` : selectedText;
            nameEl.setAttribute('data-text', nameEl.textContent);
          }
        }
      }
      
      el('model-1').addEventListener('change', updateModelNames);
      el('model-2').addEventListener('change', updateModelNames);
      el('model-3').addEventListener('change', updateModelNames);

      // Persistence: remember last selected models and toggles in localStorage
      const LS = window.localStorage;
      function setSelectIfPresent(selectId, value) {
        const sel = el(selectId);
        if (!sel || typeof value !== 'string' || !value) return;
        const exists = Array.from(sel.options).some((opt) => opt.value === value);
        if (exists) sel.value = value;
      }
      function restorePreferences() {
        // Models
        setSelectIfPresent('model-1', LS.getItem('ma:model-1'));
        setSelectIfPresent('model-2', LS.getItem('ma:model-2'));
        setSelectIfPresent('model-3', LS.getItem('ma:model-3'));
        // Toggles
        const e1 = LS.getItem('ma:enable-model1'); if (e1 !== null) el('enable-model1').checked = e1 === '1';
        const e2 = LS.getItem('ma:enable-model2'); if (e2 !== null) el('enable-model2').checked = e2 === '1';
        const e3 = LS.getItem('ma:enable-model3'); if (e3 !== null) el('enable-model3').checked = e3 === '1';
        const sr = LS.getItem('ma:show-reasoning'); if (sr !== null) el('show-reasoning').checked = sr === '1';
        const dv = LS.getItem('ma:video'); if (dv !== null) { const on = dv === '1'; el('toggle-video').checked = on; /* enable video after it becomes ready; keep image until then */ }
        const dk = LS.getItem('ma:dark'); if (dk !== null) { const on = dk === '1'; el('toggle-dark').checked = on; document.body.classList.toggle('dark', on); }
        // Advanced JSON (optional)
        const advArea = document.getElementById('advancedJson');
        const advSaved = LS.getItem('ma:advancedJson');
        if (advArea && typeof advSaved === 'string' && advSaved.length) advArea.value = advSaved;
        // Apply visuals after restoring
        updateModelNames();
        applyVisibility();
      }
      function wirePersistence() {
        // Model selects
        el('model-1').addEventListener('change', () => LS.setItem('ma:model-1', el('model-1').value || ''));
        el('model-2').addEventListener('change', () => LS.setItem('ma:model-2', el('model-2').value || ''));
        el('model-3').addEventListener('change', () => LS.setItem('ma:model-3', el('model-3').value || ''));
        // Toggles
        el('enable-model1').addEventListener('change', () => LS.setItem('ma:enable-model1', el('enable-model1').checked ? '1' : '0'));
        el('enable-model2').addEventListener('change', () => LS.setItem('ma:enable-model2', el('enable-model2').checked ? '1' : '0'));
        el('enable-model3').addEventListener('change', () => LS.setItem('ma:enable-model3', el('enable-model3').checked ? '1' : '0'));
        el('show-reasoning').addEventListener('change', () => LS.setItem('ma:show-reasoning', el('show-reasoning').checked ? '1' : '0'));
        // Advanced JSON
        const advArea = document.getElementById('advancedJson');
        if (advArea) {
          let advTimer = null;
          advArea.addEventListener('input', () => {
            if (advTimer) clearTimeout(advTimer);
            advTimer = setTimeout(() => LS.setItem('ma:advancedJson', advArea.value || ''), 250);
          });
        }
        // New toggles
        const tv = el('toggle-video');
        const td = el('toggle-dark');
        function applyVideoToggle(on) {
          const video = document.getElementById('bgVideo');
          LS.setItem('ma:video', on ? '1' : '0');
          if (!video) return;
          if (on) {
            const show = () => { document.body.classList.add('video-on'); };
            if (video.readyState >= 2) show(); else video.addEventListener('loadeddata', show, { once: true });
            video.play?.().catch(() => {});
          } else {
            document.body.classList.remove('video-on');
            video.pause?.();
          }
        }
        if (tv) tv.addEventListener('change', () => { const on = tv.checked; applyVideoToggle(on); });
        if (td) td.addEventListener('change', () => { const on = td.checked; document.body.classList.toggle('dark', on); LS.setItem('ma:dark', on ? '1' : '0'); });
        // Background upload
        const upBtn = document.getElementById('bgUploadBtn');
        const clrBtn = document.getElementById('bgClearBtn');
        const upInp = document.getElementById('bgUpload');
        function applyBg(url) {
          try {
            LS.setItem('ma:bg-image', url || '');
          } catch {}
          if (url) {
            document.body.style.backgroundImage = `url('${url}')`;
            document.body.classList.remove('video-on');
            if (tv) tv.checked = false;
          } else {
            document.body.style.backgroundImage = "url('michael-fousert-lE5-z4nTCTQ-unsplash.jpg')";
          }
        }
        if (upBtn && upInp) {
          upBtn.addEventListener('click', () => upInp.click());
          upInp.addEventListener('change', (e) => {
            const file = e.target.files && e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = () => applyBg(reader.result);
            reader.readAsDataURL(file);
          });
        }
        if (clrBtn) clrBtn.addEventListener('click', () => applyBg(''));
        // Restore custom bg if any
        const savedBg = LS.getItem('ma:bg-image');
        if (savedBg) applyBg(savedBg);
        // If user had video enabled previously, enable it only after it's ready
        const wantVideo = LS.getItem('ma:video') === '1';
        if (wantVideo) applyVideoToggle(true);
      }
      restorePreferences();
      wirePersistence();
      updateModelNames();

      // ----- Layout persistence (drag positions) -----
      function layoutStorageKey() { return 'ma:layout'; }
      function hasSavedLayout() { return !!LS.getItem(layoutStorageKey()); }
      function saveLayoutForCard(cardId, spec) {
        let current = null;
        try { current = JSON.parse(LS.getItem(layoutStorageKey()) || '{}'); } catch {}
        if (!current || typeof current !== 'object') current = {};
        if (!current.cards) current.cards = {};
        current.cards[cardId] = spec;
        LS.setItem(layoutStorageKey(), JSON.stringify(current));
      }
      function applySavedLayout() {
        let saved = null;
        try { saved = JSON.parse(LS.getItem(layoutStorageKey()) || 'null'); } catch {}
        if (!saved || !saved.cards) return;
        const container = document.getElementById('answers');
        if (!container) return;
        
        // Switch to isolated layout if we have any saved positions
        container.classList.add('isolated');
        
        ['card-model1','card-model2','card-model3'].forEach((id) => {
          const spec = saved.cards[id];
          const card = document.getElementById(id);
          if (!card || !spec) return;
          
          // Make all cards absolutely positioned in isolated mode
          card.style.position = 'absolute';
          card.style.left = (spec.left ?? 0) + 'px';
          card.style.top = (spec.top ?? 0) + 'px';
          card.style.width = (spec.width ?? 400) + 'px';
          card.style.height = (spec.height ?? 300) + 'px';
          card.style.zIndex = String(spec.zIndex ?? 1);
        });
        
        updateIsolatedLayout();
      }
      function clearSavedLayout() {
        LS.removeItem(layoutStorageKey());
        const container = document.getElementById('answers');
        if (!container) return;
        container.classList.remove('isolated');
        container.style.minHeight = '';
        ['card-model1','card-model2','card-model3'].forEach((id) => {
          const card = document.getElementById(id);
          if (!card) return;
          card.style.position = '';
          card.style.left = '';
          card.style.top = '';
          card.style.width = '';
          card.style.height = '';
          card.style.zIndex = '';
        });
      }
      function updateContainerHeightForLayout() {
        const container = document.getElementById('answers');
        if (!container || !container.classList.contains('custom-layout')) return;
        const cards = ['card-model1','card-model2','card-model3']
          .map((id) => document.getElementById(id))
          .filter(Boolean);
        let maxBottom = 0;
        cards.forEach((c) => {
          const top = parseFloat(c.style.top) || 0;
          const rect = c.getBoundingClientRect();
          const height = rect.height || 0;
          const bottom = top + height;
          if (bottom > maxBottom) maxBottom = bottom;
        });
        container.style.height = Math.max(420, Math.ceil(maxBottom + 16)) + 'px';
      }

      // Restore saved layouts on page load
      applySavedLayout();
      // Keep container height in sync when window resizes
      window.addEventListener('resize', updateIsolatedLayout);

      // Save all current absolute positions back to storage (for safety on reloads)
      function saveAllLayouts() {
        const container = document.getElementById('answers');
        if (!container || !container.classList.contains('custom-layout')) return;
        const current = { cards: {} };
        ['card-model1','card-model2','card-model3'].forEach((id) => {
          const card = document.getElementById(id);
          if (!card) return;
          const left = parseFloat(card.style.left);
          const top = parseFloat(card.style.top);
          const width = parseFloat(card.style.width);
          const height = parseFloat(card.style.height);
          const zIndex = parseInt(card.style.zIndex);
          if (!Number.isFinite(left) || !Number.isFinite(top) || !Number.isFinite(width)) return;
          current.cards[id] = { 
            left: Math.round(left), 
            top: Math.round(top), 
            width: Math.round(width),
            height: Number.isFinite(height) ? Math.round(height) : undefined,
            zIndex: Number.isFinite(zIndex) ? zIndex : 1
          };
        });
        try { LS.setItem(layoutStorageKey(), JSON.stringify(current)); } catch {}
      }
      // window.addEventListener('beforeunload', saveAllLayouts);

      // Reset helper: restore default 1-2-1 grid
      function clearSavedColumns() {
        const answers = document.getElementById('answers');
        if (answers) answers.style.gridTemplateColumns = '1fr 2fr 1fr';
      }
      
      // Reasoning helpers (for thinking models like OpenAI o3*)
      function isThinkingModel(modelValue) {
        if (!modelValue) return false;
        return /^o3(\b|[-_])/.test(modelValue) || /o3-pro/.test(modelValue);
      }
      function withBriefReasoning(baseSystem, modelValue, enabled) {
        if (!enabled && !isThinkingModel(modelValue)) return baseSystem || '';
        const base = baseSystem ? baseSystem + '\n' : '';
        return (
          base +
          "First provide a very brief reasoning section (1-3 short bullets, max ~400 characters) prefixed with 'Reasoning:', then on a new line provide 'Answer:' with the final concise answer."
        );
      }
      // Spark management per model
      const __sparkTimers = { model1: null, model2: null, model3: null };
      const SPARK_EMOJIS = ['✨','💫','⭐️','🌟','💖','💚','💙','💜','🧡','💛','💗','💥','💞','💓','💘','🪄','🎇','🎆'];
      function emitSparkFor(card) {
        const titleSpan = card.querySelector('.title span');
        if (!titleSpan) return;
        const spark = document.createElement('span');
        spark.className = 'spark';
        spark.textContent = SPARK_EMOJIS[Math.floor(Math.random() * SPARK_EMOJIS.length)];
        // random horizontal offset and slight random duration tweak via CSS var
        const x = (Math.random() * 120 - 60).toFixed(0) + 'px';
        spark.style.setProperty('--x', x);
        spark.style.fontSize = (12 + Math.random() * 12).toFixed(0) + 'px';
        spark.style.setProperty('--rot', (Math.random()*40 - 20).toFixed(0) + 'deg');
        spark.style.setProperty('--d', (0.9 + Math.random()*0.8).toFixed(2) + 's');
        titleSpan.appendChild(spark);
        spark.addEventListener('animationend', () => spark.remove());
      }
      function startSparks(modelId) { /* disabled visual sparks in subtle mode */ }
      function stopSparks(modelId) { const t = __sparkTimers[modelId]; if (t) { clearInterval(t); __sparkTimers[modelId] = null; } }
      function setLoading(modelId, loading) {
        const card = document.getElementById(`card-${modelId}`);
        if (!card) return;
        if (loading) {
          card.classList.add('loading');
          // Randomize blob positions per session for partial coverage
          const b1x = (20 + Math.random() * 60).toFixed(1) + '%';
          const b1y = (20 + Math.random() * 60).toFixed(1) + '%';
          const b2x = (20 + Math.random() * 60).toFixed(1) + '%';
          const b2y = (20 + Math.random() * 60).toFixed(1) + '%';
          card.style.setProperty('--b1x', b1x);
          card.style.setProperty('--b1y', b1y);
          card.style.setProperty('--b2x', b2x);
          card.style.setProperty('--b2y', b2y);
        } else {
          card.classList.remove('loading');
        }
        if (loading) {
          // Set hue once per card; keep afterwards
          let hue = card.dataset.hue;
          if (!hue) {
            hue = Math.floor(Math.random() * 360);
            card.dataset.hue = hue;
          }
          card.style.setProperty('--tint-h', hue);
          card.classList.remove('tinted');
          startSparks(modelId);
        } else {
          card.classList.add('tinted');
          stopSparks(modelId);
        }
      }

      // Hide/show cards and adjust grid based on model toggles
      function applyVisibility() {
        const vis = {
          model1: document.getElementById('enable-model1').checked,
          model2: document.getElementById('enable-model2').checked,
          model3: document.getElementById('enable-model3').checked,
        };
        const answers = document.getElementById('answers');
        const visibleCount = Object.values(vis).filter(Boolean).length;

        if (visibleCount === 1) {
          answers.style.gridTemplateColumns = '1fr';
        } else if (visibleCount === 2) {
          answers.style.gridTemplateColumns = '1fr 1fr';
        } else {
          answers.style.gridTemplateColumns = '1fr 2fr 1fr';
        }
        
        document.getElementById('card-model1').style.display = vis.model1 ? '' : 'none';
        document.getElementById('card-model2').style.display = vis.model2 ? '' : 'none';
        document.getElementById('card-model3').style.display = vis.model3 ? '' : 'none';
      }
      document.getElementById('enable-model1').addEventListener('change', applyVisibility);
      document.getElementById('enable-model2').addEventListener('change', applyVisibility);
      document.getElementById('enable-model3').addEventListener('change', applyVisibility);
      applyVisibility();
      // Re-apply saved layout after visibility adjustments
      applySavedLayout();

      // Hide/Maximize/Restore
      let __prevVisibility = null;
      function checkboxFor(modelId) { return document.getElementById(`enable-${modelId}`); }
      function hideModel(modelId) {
        const cb = checkboxFor(modelId);
        if (cb) { cb.checked = false; applyVisibility(); }
      }
      function maximizeModel(modelId) {
        __prevVisibility = {
          model1: checkboxFor('model1').checked,
          model2: checkboxFor('model2').checked,
          model3: checkboxFor('model3').checked,
        };
        checkboxFor('model1').checked = modelId === 'model1';
        checkboxFor('model2').checked = modelId === 'model2';
        checkboxFor('model3').checked = modelId === 'model3';
        applyVisibility();
        // Switch answers area to single mode and enlarge selected (preserve isolated positions)
        const answers = document.getElementById('answers');
        answers.classList.add('single');
        ['model1','model2','model3'].forEach((m) => {
          const card = document.getElementById('card-' + m);
          if (!card) return;
          const isTarget = modelId === m;
          if (isTarget) {
            // Save current inline geometry for later restore
            card.dataset.prevPosition = card.style.position || '';
            card.dataset.prevLeft = card.style.left || '';
            card.dataset.prevTop = card.style.top || '';
            card.dataset.prevWidth = card.style.width || '';
            card.dataset.prevHeight = card.style.height || '';
            card.dataset.prevZ = card.style.zIndex || '';
            // Clear to allow CSS .card.maximized to take full width/height
          card.style.position = '';
          card.style.left = '';
          card.style.top = '';
          card.style.width = '';
            card.style.height = '';
            // keep zIndex cleared so stacking doesn't block others when exiting
          card.style.zIndex = '';
          }
          card.classList.toggle('maximized', isTarget);
        });
        // Hide brand for full utilization and scroll to the card
        document.getElementById('brand').classList.add('hidden');
        const card = document.getElementById(`card-${modelId}`);
        document.body.classList.add('max-on');
        // scroll prompt panel out of view so card fills page
        const topPanel = document.getElementById('panel-top');
        const y = topPanel.offsetTop + topPanel.offsetHeight + 8;
        window.scrollTo({ top: y, behavior: 'smooth' });
      }
      function restoreAll() {
        if (!__prevVisibility) return;
        const answers = document.getElementById('answers');
        answers.classList.remove('single');
        ['model1','model2','model3'].forEach((m) => {
          const card = document.getElementById('card-' + m);
          if (!card) return;
          // Restore geometry if we saved it during maximize
          if (card.dataset.prevPosition !== undefined) {
            card.style.position = card.dataset.prevPosition;
            card.style.left = card.dataset.prevLeft;
            card.style.top = card.dataset.prevTop;
            card.style.width = card.dataset.prevWidth;
            card.style.height = card.dataset.prevHeight;
            card.style.zIndex = card.dataset.prevZ;
            delete card.dataset.prevPosition;
            delete card.dataset.prevLeft;
            delete card.dataset.prevTop;
            delete card.dataset.prevWidth;
            delete card.dataset.prevHeight;
            delete card.dataset.prevZ;
          }
          card.classList.remove('maximized');
        });
        checkboxFor('model1').checked = __prevVisibility.model1;
        checkboxFor('model2').checked = __prevVisibility.model2;
        checkboxFor('model3').checked = __prevVisibility.model3;
        applyVisibility();
        __prevVisibility = null;
        document.getElementById('brand').classList.remove('hidden');
        document.body.classList.remove('max-on');
        // If isolated layout was never initialized, just reset grid like a safe fallback
        const answersHadIsolated = document.getElementById('answers').classList.contains('isolated');
        if (!answersHadIsolated) {
          clearSavedLayout();
          clearSavedColumns();
        }
      }



      // Draggable cards (for free positioning); kept in case user prefers manual layout
      function makeDraggable(cardId) {
        const card = document.getElementById(cardId);
        if (!card) return;
        const handle = card; // use the whole card as drag handle, with guards below
        let dragging = false, startX = 0, startY = 0, startLeft = 0, startTop = 0;
        function isInteractive(el) { return !!el.closest('input, textarea, select, button, .mini, .convo, .drag-handle'); }
        function onPointerDown(e) {
          if (isInteractive(e.target)) return;
          
          // Initialize isolated mode for all cards if not already done
          initializeAllCardsForIsolation();
          
          dragging = true;
          const rect = card.getBoundingClientRect();
          startLeft = rect.left;
          startTop = rect.top;
          startX = e.clientX || (e.touches && e.touches[0]?.clientX) || 0;
          startY = e.clientY || (e.touches && e.touches[0]?.clientY) || 0;
          card.style.position = 'fixed';
          card.style.left = `${startLeft}px`;
          card.style.top = `${startTop}px`;
          card.style.width = `${rect.width}px`;
          card.style.zIndex = 2000;
          document.addEventListener('pointermove', onPointerMove);
          document.addEventListener('pointerup', onPointerUp);
          document.addEventListener('touchmove', onPointerMove, { passive: false });
          document.addEventListener('touchend', onPointerUp);
        }
        function onPointerMove(e) {
          if (!dragging) return;
          const x = e.clientX || (e.touches && e.touches[0]?.clientX) || 0;
          const y = e.clientY || (e.touches && e.touches[0]?.clientY) || 0;
          const dx = x - startX;
          const dy = y - startY;
          card.style.left = `${startLeft + dx}px`;
          card.style.top = `${startTop + dy}px`;
          if (e.cancelable) e.preventDefault();
        }
        function onPointerUp() {
          dragging = false;
          document.removeEventListener('pointermove', onPointerMove);
          document.removeEventListener('pointerup', onPointerUp);
          document.removeEventListener('touchmove', onPointerMove);
          document.removeEventListener('touchend', onPointerUp);
          // Convert fixed drag position into absolute position within the answers container and persist
          const container = document.getElementById('answers');
          if (!container) return;
          container.classList.add('isolated');
          
          const rect = card.getBoundingClientRect();
          const containerRect = container.getBoundingClientRect();
          const left = rect.left - containerRect.left + (container.scrollLeft || 0);
          const top = rect.top - containerRect.top + (container.scrollTop || 0);
          
          card.style.position = 'absolute';
          card.style.left = `${Math.max(0, Math.round(left))}px`;
          card.style.top = `${Math.max(0, Math.round(top))}px`;
          card.style.width = `${Math.round(rect.width)}px`;
          card.style.zIndex = '1';
          
          const spec = getCurrentCardSpec(cardId);
          if (spec) {
            saveLayoutForCard(cardId, spec);
          }
          updateIsolatedLayout();
          card.classList.remove('dragging');
        }
        handle.addEventListener('pointerdown', onPointerDown);
        handle.addEventListener('touchstart', onPointerDown, { passive: true });
        // Also add four corner drag handles for explicit dragging
        ['tl','tr','bl','br'].forEach((pos) => {
          const h = document.createElement('div');
          h.className = `drag-handle ${pos}`;
          card.appendChild(h);
          h.addEventListener('pointerdown', (e) => {
            dragging = true;
            const rect = card.getBoundingClientRect();
            startLeft = rect.left;
            startTop = rect.top;
            startX = e.clientX || (e.touches && e.touches[0]?.clientX) || 0;
            startY = e.clientY || (e.touches && e.touches[0]?.clientY) || 0;
            card.style.position = 'fixed';
            card.style.left = `${startLeft}px`;
            card.style.top = `${startTop}px`;
            card.style.width = `${rect.width}px`;
            card.style.zIndex = 2000;
            card.classList.add('dragging');
            document.addEventListener('pointermove', onPointerMove);
            document.addEventListener('pointerup', onPointerUp);
            document.addEventListener('touchmove', onPointerMove, { passive: false });
            document.addEventListener('touchend', onPointerUp);
            e.stopPropagation();
            e.preventDefault();
          });
        });
      }

      // Bring clicked card to front
      function bringToFront(cardId) {
        const card = document.getElementById(cardId);
        if (!card) return;
        
        // Find the highest z-index among all cards
        const allCards = ['card-model1', 'card-model2', 'card-model3'];
        let maxZ = 0;
        allCards.forEach(id => {
          const c = document.getElementById(id);
          if (c && c.style.zIndex) {
            const z = parseInt(c.style.zIndex) || 0;
            if (z > maxZ) maxZ = z;
          }
        });
        
        // Set this card's z-index higher than the max
        card.style.zIndex = String(maxZ + 1);
        
        // Save the updated z-index
        const currentSpec = getCurrentCardSpec(cardId);
        if (currentSpec) {
          currentSpec.zIndex = maxZ + 1;
          saveLayoutForCard(cardId, currentSpec);
        }
      }
      
      // Get current card specifications
      function getCurrentCardSpec(cardId) {
        const card = document.getElementById(cardId);
        if (!card) return null;
        
        return {
          left: parseFloat(card.style.left) || 0,
          top: parseFloat(card.style.top) || 0,
          width: parseFloat(card.style.width) || 240,
          height: parseFloat(card.style.height) || 200,
          zIndex: parseInt(card.style.zIndex) || 1
        };
      }

      // Make cards completely isolated - resizable and positionable independently
      function makeResizable(cardId) {
        const card = document.getElementById(cardId);
        if (!card) return;
        
        // Add click-to-front functionality (but only if already in isolated mode)
        card.addEventListener('pointerdown', () => {
          const container = document.getElementById('answers');
          if (container && container.classList.contains('isolated')) {
            bringToFront(cardId);
          }
        });
        card.addEventListener('click', () => {
          const container = document.getElementById('answers');
          if (container && container.classList.contains('isolated')) {
            bringToFront(cardId);
          }
        });
        
        // Add resize handles
        const handles = ['n','s','w','e','nw','ne','sw','se'];
        handles.forEach(dir => {
          const handle = document.createElement('div');
          handle.className = `resize-handle resize-${dir}`;
          card.appendChild(handle);
          
          handle.addEventListener('pointerdown', (e) => {
            e.preventDefault();
            e.stopPropagation();
            
            // Initialize isolated mode for all cards if not already done
            initializeAllCardsForIsolation();
            
            const startX = e.clientX;
            const startY = e.clientY;
            const startRect = card.getBoundingClientRect();
            const container = document.getElementById('answers');
            const containerRect = container.getBoundingClientRect();
            
            function onMove(e) {
              const dx = e.clientX - startX;
              const dy = e.clientY - startY;
              
              let newWidth = startRect.width;
              let newHeight = startRect.height;
              let newLeft = startRect.left - containerRect.left;
              let newTop = startRect.top - containerRect.top;
              
              // Calculate new dimensions and position based on direction
              if (dir.includes('e')) newWidth = Math.max(240, startRect.width + dx);
              if (dir.includes('w')) { 
                newWidth = Math.max(240, startRect.width - dx); 
                newLeft = Math.max(0, (startRect.left - containerRect.left) + dx);
              }
              if (dir.includes('s')) newHeight = Math.max(200, startRect.height + dy);
              if (dir.includes('n')) { 
                newHeight = Math.max(200, startRect.height - dy); 
                newTop = Math.max(0, (startRect.top - containerRect.top) + dy);
              }
              
              // Apply changes immediately
              card.style.width = `${newWidth}px`;
              card.style.height = `${newHeight}px`;
              card.style.left = `${newLeft}px`;
              card.style.top = `${newTop}px`;
            }
            
            function onUp() {
              document.removeEventListener('pointermove', onMove);
              document.removeEventListener('pointerup', onUp);
              
              // Save the final state
              const spec = getCurrentCardSpec(cardId);
              if (spec) {
                saveLayoutForCard(cardId, spec);
                updateIsolatedLayout();
              }
            }
            
            document.addEventListener('pointermove', onMove);
            document.addEventListener('pointerup', onUp);
          });
        });
      }
      
      // Initialize all cards for isolated positioning when first interaction happens
      function initializeAllCardsForIsolation() {
        const container = document.getElementById('answers');
        if (!container) return;
        // Only initialize if not already in isolated mode
        if (container.classList.contains('isolated')) return;

        const allCards = ['card-model1', 'card-model2', 'card-model3'];
        // Capture rectangles BEFORE changing layout
        const preRects = {};
        allCards.forEach((cardId) => {
          const card = document.getElementById(cardId);
          if (!card) return;
          preRects[cardId] = card.getBoundingClientRect();
        });

        // Switch to isolated layout
        container.classList.add('isolated');
        // Rect after layout change (for relative offsets)
        const containerRect = container.getBoundingClientRect();

        // Apply absolute positions using the pre-change rectangles
        allCards.forEach((cardId, index) => {
          const card = document.getElementById(cardId);
          const rect = preRects[cardId];
          if (!card || !rect) return;
          card.style.position = 'absolute';
          card.style.left = `${Math.max(0, Math.round(rect.left - containerRect.left))}px`;
          card.style.top = `${Math.max(0, Math.round(rect.top - containerRect.top))}px`;
          card.style.width = `${Math.round(rect.width)}px`;
          card.style.height = `${Math.round(rect.height)}px`;
          // preserve existing z-index if any, else assign stacking by order
          if (!card.style.zIndex) card.style.zIndex = String(index + 1);
        });
      }
      
      // Initialize a single card for isolated positioning (legacy function)
      function initializeIsolatedCard(cardId) {
        initializeAllCardsForIsolation();
      }
      
      // Update isolated layout container height
      function updateIsolatedLayout() {
        const container = document.getElementById('answers');
        if (!container || !container.classList.contains('isolated')) return;
        
        const cards = ['card-model1','card-model2','card-model3']
          .map((id) => document.getElementById(id))
          .filter(Boolean);
        
        let maxBottom = 500; // minimum height
        cards.forEach((card) => {
          const top = parseFloat(card.style.top) || 0;
          const height = parseFloat(card.style.height) || 200;
          const bottom = top + height;
          if (bottom > maxBottom) maxBottom = bottom;
        });
        
        container.style.minHeight = `${Math.ceil(maxBottom + 20)}px`;
      }

      ['card-model1','card-model2','card-model3'].forEach(makeDraggable);
      ['card-model1','card-model2','card-model3'].forEach(makeResizable);
      async function ask() {
        console.log('Frontend: Before ask(), window.__histories:', window.__histories);
        const enabledModels = ['model1','model2','model3'].filter(m => el(`enable-${m}`).checked && el(`model-${m.slice(-1)}`).value);
        if (enabledModels.length === 0) return;

        askBtn.disabled = true;
        enabledModels.forEach(m => setLoading(m, true));

        const adv = parseAdvanced();
        const promptText = el('prompt').value;
        const showReasoning = el('show-reasoning').checked;

        const jobs = enabledModels.map(async (modelId) => {
          const idx = modelId.slice(-1);
          const modelValue = el(`model-${idx}`).value;
          const provider = getProviderFromModel(modelValue);
          if (!provider) return;

          try {
            const res = await fetch('/api/ask', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                prompt: promptText,
                system: withBriefReasoning((adv[provider]?.system ?? adv.system) ?? '', modelValue, showReasoning),
                histories: window.__histories,
                modelId,
                providers: { [provider]: true },
                models: { [provider]: modelValue },
                temperature: (adv[provider]?.temperature ?? adv.temperature) ?? 0.2,
                maxTokens: (adv[provider]?.maxTokens ?? adv.maxTokens) ?? 1024,
                timeoutMs: (adv[provider]?.timeoutMs ?? adv.timeoutMs) ?? 30000,
              }),
            });
            const data = await res.json();
            const r = data[provider];
            console.log(`Frontend: ${modelId} response:`, r);
            if (r?.ok) {
              const box = out[modelId];
              const u = document.createElement('div'); u.className = 'msg user'; u.textContent = promptText;
              const a = document.createElement('div'); a.className = 'msg assistant'; a.textContent = r.text || '';
              box.appendChild(u); box.appendChild(a); box.dataset.empty = 'false';
              
              // Smart scroll for "Ask all": show question + start of answer
              if (box.children.length > 2) {
                u.scrollIntoView({ behavior: 'smooth', block: 'center' });
              } else {
                box.scrollTop = box.scrollHeight;
              }
              window.__histories[modelId].push(
                { role: 'user', content: promptText },
                { role: 'assistant', content: r.text || '' }
              );
              console.log(`Frontend: Added to ${modelId} history, now ${window.__histories[modelId].length} items`);
            } else {
              const box = out[modelId];
              const errDiv = document.createElement('div');
              errDiv.className = 'msg error';
              errDiv.textContent = r?.error || 'Error';
              box.appendChild(errDiv);
              box.dataset.empty = 'false';
            }
          } catch (err) {
            console.error(`Error with ${modelId}:`, err);
            const box = out[modelId];
            const errDiv = document.createElement('div');
            errDiv.className = 'msg error';
            errDiv.textContent = 'Network error';
            box.appendChild(errDiv);
            box.dataset.empty = 'false';
          } finally {
            setLoading(modelId, false);
          }
        });

        try {
          await Promise.allSettled(jobs);
        } finally {
          askBtn.disabled = false;
        }
      }
      askBtn.addEventListener('click', ask);
      
      // Stream Model 1 if it's an OpenAI model
      async function askStream() {
        if (!streamBtn) return;
        const model1Value = el('model-1').value;
        const provider = getProviderFromModel(model1Value);
        if (provider !== 'openai') {
          alert('Streaming is only available for OpenAI models. Please select an OpenAI model for Model 1.');
          return;
        }
        
        streamBtn.disabled = true;
        setLoading('model1', true);
        const adv = parseAdvanced();
        const body = {
          prompt: el('prompt').value,
          system: withBriefReasoning((adv.openai?.system ?? adv.system) ?? '', model1Value, el('show-reasoning')?.checked),
          model: model1Value,
          temperature: (adv.openai?.temperature ?? adv.temperature) ?? 0.2,
          maxTokens: (adv.openai?.maxTokens ?? adv.maxTokens),
          maxCompletionTokens: (adv.openai?.max_completion_tokens ?? adv.max_completion_tokens) ?? 1024,
          histories: window.__histories,
          modelId: 'model1',
        };
        const res = await fetch('/api/stream', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(body) });
        if (!res.body) return ask();
        const reader = res.body.getReader();
        const decoder = new TextDecoder();

        const box = out.model1;
        box.dataset.empty = 'false';
        const promptText = el('prompt').value;
        const u = document.createElement('div'); u.className = 'msg user'; u.textContent = promptText; box.appendChild(u);
        const a = document.createElement('div'); a.className = 'msg assistant'; box.appendChild(a);
        
        // Position view to show question + start of streaming answer
        if (box.children.length > 2) {
          u.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }

        let accumulated = '';
        let buffer = '';
        try {
          while (true) {
            const { value, done } = await reader.read();
            if (done) break;
            buffer += decoder.decode(value, { stream: true });
            const events = buffer.split('\n\n');
            buffer = events.pop();
            for (const evt of events) {
              if (!evt.startsWith('data:')) continue;
              const json = evt.slice(5).trim();
              try {
                const msg = JSON.parse(json);
                if (msg.delta) { 
                  accumulated += msg.delta;
                  a.textContent = accumulated; 
                  // Don't auto-scroll during streaming - let user read from context
                }
                if (msg.done) { 
                  
                  // Add to conversation history
                  window.__histories.model1.push(
                    { role: 'user', content: promptText },
                    { role: 'assistant', content: accumulated }
                  );
                }
              } catch {}
            }
          }
        } catch (err) {
          a.innerHTML = '<span class="error">Streaming error: ' + (err?.message || err) + '</span>';
        } finally {
          streamBtn.disabled = false;
          setLoading('model1', false);
        }
      }
      // Wire up Stream button
      if (streamBtn) streamBtn.addEventListener('click', askStream);
      
      // Ctrl/Cmd+Shift+Enter to stream OpenAI
      document.addEventListener('keydown', (e) => {
        if ((e.metaKey || e.ctrlKey) && e.shiftKey && e.key === 'Enter') askStream();
      });
      if (drawBtn) drawBtn.addEventListener('click', async () => {
        try {
          drawBtn.disabled = true;
          const res = await fetch('/api/draw', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ prompt: el('prompt').value, size: '1024x1024' }),
          });
          const data = await res.json();
          if (data?.ok && data.image) {
            const img = new Image();
            img.src = data.image;
            img.style.maxWidth = '100%';
            img.style.borderRadius = '10px';
            const box = out.model1;
            const u = document.createElement('div'); u.className = 'msg user'; u.textContent = el('prompt').value;
            const a = document.createElement('div'); a.className = 'msg assistant'; a.appendChild(img);
            box.appendChild(u); box.appendChild(a); box.scrollTop = box.scrollHeight; box.dataset.empty = 'false';
          } else {
            alert(data?.error || 'Failed to draw image');
          }
        } finally {
          drawBtn.disabled = false;
        }
      });
      document.addEventListener('keydown', (e) => {
        if ((e.metaKey || e.ctrlKey) && e.key === 'Enter') ask();
      });

      // Advanced button toggles details
      const advBtn = document.getElementById('advBtn');
      const advDetails = document.getElementById('advanced');
      if (advBtn && advDetails) {
        // ensure hidden on load
        advDetails.open = false;
        advBtn.addEventListener('click', () => {
          advDetails.open = !advDetails.open;
        });
      }

      // Parse advanced JSON textarea safely
      function parseAdvanced() {
        const t = document.getElementById('advancedJson');
        if (!t) return {};
        try {
          const data = JSON.parse(t.value || '{}');
          return typeof data === 'object' && data ? data : {};
        } catch (_) { return {}; }
      }

      async function askSingle(modelId) {
        const modelValue = el(`model-${modelId.slice(-1)}`).value;
        if (!modelValue) return;
        const provider = getProviderFromModel(modelValue);
        if (!provider) return;
        
        askBtn.disabled = true;
        setLoading(modelId, true);
        const promptMain = el('prompt').value;
        const followInput = el('follow-' + modelId);
        const followText = followInput ? followInput.value.trim() : '';
        const usePrompt = followText || promptMain;
        const showReasoning = el('show-reasoning').checked;
        try {
          const adv = parseAdvanced();
          console.log(`Frontend: Before request, ${modelId} history has ${window.__histories[modelId]?.length || 0} items`);
          const body = {
            prompt: usePrompt,
            system: withBriefReasoning((adv[provider]?.system ?? adv.system) ?? '', modelValue, showReasoning),
            histories: window.__histories,
            modelId,
            providers: {
              [provider]: true,
            },
            models: {
              [provider]: modelValue,
            },
            temperature: (adv[provider]?.temperature ?? adv.temperature) ?? 0.2,
            maxTokens: (adv[provider]?.maxTokens ?? adv.maxTokens),
            maxCompletionTokens: (adv[provider]?.max_completion_tokens ?? adv.max_completion_tokens) ?? 1024,
            timeoutMs: (adv[provider]?.timeoutMs ?? adv.timeoutMs) ?? 30000,
            showReasoning: showReasoning,
          };
          const res = await fetch('/api/ask', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(body),
          });
          const data = await res.json();
          const r = data[provider];
          if (r?.ok) {
            const box = out[modelId];
            const u = document.createElement('div'); u.className = 'msg user'; u.textContent = usePrompt;
            const a = document.createElement('div'); a.className = 'msg assistant'; a.textContent = r.text || '';
              box.appendChild(u); box.appendChild(a); box.dataset.empty = 'false';
              
              // Clear follow-up input if it was used
              if (followText && followInput) followInput.value = '';
              
              // Smart scroll: show some context + new question + start of answer
              if (box.children.length > 2) {
                // Scroll to show the new question (not the very bottom)
                u.scrollIntoView({ behavior: 'smooth', block: 'center' });
              } else {
                // First conversation, normal scroll
                box.scrollTop = box.scrollHeight;
              }
              
            const latEl = document.getElementById('lat-' + modelId);
            if (latEl) latEl.textContent = `${r.latencyMs} ms`;
            window.__histories[modelId].push(
              { role: 'user', content: usePrompt },
              { role: 'assistant', content: r.text || '' }
            );
            console.log(`Frontend: After adding to ${modelId} history, now ${window.__histories[modelId].length} items`);
          } else {
            out[modelId].innerHTML = '<span class="error">' + (r?.error || 'Error') + '</span>';
            const latEl = document.getElementById('lat-' + modelId);
            if (latEl) latEl.textContent = '';
          }
        } catch (err) {
          console.error(`Error in askSingle(${modelId}):`, err);
        } finally {
          askBtn.disabled = false;
          setLoading(modelId, false);
        }
      }

      const btnModel1 = document.getElementById('ask-model1');
      const btnModel2 = document.getElementById('ask-model2');
      const btnModel3 = document.getElementById('ask-model3');
      if (btnModel1) btnModel1.addEventListener('click', () => askSingle('model1'));
      if (btnModel2) btnModel2.addEventListener('click', () => askSingle('model2'));
      if (btnModel3) btnModel3.addEventListener('click', () => askSingle('model3'));

      // Clear functions
      function clearConversation(modelId) {
        console.log(`Frontend: clearConversation called for ${modelId}`, new Error().stack);
        const box = out[modelId];
        if (box) {
          box.textContent = '';
          box.dataset.empty = 'true';
        }
        if (!window.__histories) window.__histories = { model1: [], model2: [], model3: [] };
        if (window.__histories[modelId]) window.__histories[modelId] = [];
        const lat = document.getElementById('lat-' + modelId);
        if (lat) lat.textContent = '';
        const follow = document.getElementById('follow-' + modelId);
        if (follow) follow.value = '';
      }
      function clearAllConversations() {
        ['model1','model2','model3'].forEach(clearConversation);
      }
      const resetAllBtn = document.getElementById('resetAllBtn');
      if (resetAllBtn) resetAllBtn.addEventListener('click', clearAllConversations);
      const resetLayoutBtn = document.getElementById('resetLayoutBtn');
      if (resetLayoutBtn) resetLayoutBtn.addEventListener('click', () => { clearSavedLayout(); clearSavedColumns(); });
      const clear1 = document.getElementById('clear-model1');
      const clear2 = document.getElementById('clear-model2');
      const clear3 = document.getElementById('clear-model3');
      if (clear1) clear1.addEventListener('click', () => clearConversation('model1'));
      if (clear2) clear2.addEventListener('click', () => clearConversation('model2'));
      if (clear3) clear3.addEventListener('click', () => clearConversation('model3'));

      // Wire card control buttons
      // Traffic light style controls
      document.getElementById('dot-hide-model1').addEventListener('click', () => hideModel('model1'));
      document.getElementById('dot-hide-model2').addEventListener('click', () => hideModel('model2'));
      document.getElementById('dot-hide-model3').addEventListener('click', () => hideModel('model3'));
      document.getElementById('dot-max-model1').addEventListener('click', () => maximizeModel('model1'));
      document.getElementById('dot-max-model2').addEventListener('click', () => maximizeModel('model2'));
      document.getElementById('dot-max-model3').addEventListener('click', () => maximizeModel('model3'));
      document.getElementById('dot-restore-model1').addEventListener('click', restoreAll);
      document.getElementById('dot-restore-model2').addEventListener('click', restoreAll);
      document.getElementById('dot-restore-model3').addEventListener('click', restoreAll);
      // Taller/Shorter buttons (keep width, adjust height)
      function taller(modelId) {
        const card = document.getElementById('card-' + modelId);
        if (!card) return;
        const currentHeight = parseFloat(card.style.height) || card.getBoundingClientRect().height;
        card.style.height = Math.round(currentHeight + 200) + 'px';
        const spec = getCurrentCardSpec('card-' + modelId);
        if (spec) saveLayoutForCard('card-' + modelId, spec);
        updateIsolatedLayout();
      }
      function shorter(modelId) {
        const card = document.getElementById('card-' + modelId);
        if (!card) return;
        const currentHeight = parseFloat(card.style.height) || card.getBoundingClientRect().height;
        const next = Math.max(220, currentHeight - 200);
        card.style.height = Math.round(next) + 'px';
        const spec = getCurrentCardSpec('card-' + modelId);
        if (spec) saveLayoutForCard('card-' + modelId, spec);
        updateIsolatedLayout();
      }
      document.getElementById('dot-tall-model1').addEventListener('click', () => taller('model1'));
      document.getElementById('dot-tall-model2').addEventListener('click', () => taller('model2'));
      document.getElementById('dot-tall-model3').addEventListener('click', () => taller('model3'));
      document.getElementById('dot-short-model1').addEventListener('click', () => shorter('model1'));
      document.getElementById('dot-short-model2').addEventListener('click', () => shorter('model2'));
      document.getElementById('dot-short-model3').addEventListener('click', () => shorter('model3'));
    </script>
  </body>
  </html>


